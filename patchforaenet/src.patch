diff -Naru src/Makefile.inc src_modified/Makefile.inc
--- src/Makefile.inc	2025-04-08 11:32:06.105109979 +0900
+++ src_modified/Makefile.inc	2025-04-08 13:27:27.569785706 +0900
@@ -26,13 +26,16 @@
 
 OBJECTS  = aenet.o aeio.o chebyshev.o constants.o feedforward.o geometry.o \
            input.o io.o lclist.o optimize.o parallel.o potential.o random.o \
-           sfbasis.o sfsetup.o sortlib.o symmfunc.o timing.o trainset.o xsflib.o
+           sfbasis.o sfsetup.o sortlib.o symmfunc.o timing.o trainset.o xsflib.o \
+			aenet_predict.o aenet_generate.o aenet_train.o trainset_MPI.o aenet_generate_mpi.o
 
 PICOBJECTS  = aenet_pic.o aeio_pic.o chebyshev_pic.o constants_pic.o \
               feedforward_pic.o geometry_pic.o input_pic.o io_pic.o \
               lclist_pic.o optimize_pic.o parallel_pic.o potential_pic.o \
               random_pic.o sfbasis_pic.o sfsetup_pic.o sortlib_pic.o \
-              symmfunc_pic.o timing_pic.o trainset_pic.o xsflib_pic.o
+              symmfunc_pic.o timing_pic.o trainset_pic.o xsflib_pic.o \
+				aenet_predict_pic.o aenet_generate_pic.o aenet_train_pic.o \
+				aenet_generate_mpi_pic.o
 
 #------------------------------ targets -------------------------------#
 
@@ -57,7 +60,8 @@
 generate : $(TARGET1)
 train    : $(TARGET2)
 predict  : $(TARGET3)
-lib      : libaenet.a libaenet.so
+lib      : libaenet.a
+# libaenet.so
 
 %.o : %.f90
 	$(FC) $(FCFLAGS) $< -o $*.o
@@ -69,13 +73,13 @@
 	$(FC) $(FCFLAGS) $< -o $*.o
 
 %_pic.o : %.f90
-	$(FC) $(FCFLAGS) -fPIC -o $@ $<
+	$(FC) $(FCFLAGS)  -fPIC -o $@ $< 
 
 %_pic.o : %.F90
-	$(FC) $(FCFLAGS) -fPIC -o $@ $<
+	$(FC) $(FCFLAGS)  -fPIC -o $@ $< 
 
 %_pic.o : $(EXT)%.f90
-	$(FC) $(FCFLAGS) -fPIC -o $@ $<
+	$(FC) $(FCFLAGS)  -fPIC -o $@ $< 
 
 $(BIN)%.x : %.f90 $(OBJECTS) Makefile.inc
 	$(LD) $(LDFLAGS) -o $@-$(version)-$(SUFFIX) $< $(OBJECTS) $(LIB) $(NUMLIB)
@@ -83,11 +87,11 @@
 $(BIN)%.x : %.F90 $(OBJECTS) Makefile.inc
 	$(LD) $(LDFLAGS) -o $@-$(version)-$(SUFFIX) $< $(OBJECTS) $(LIB) $(NUMLIB)
 
-libaenet.a : $(OBJECTS) Makefile.inc
-	$(AR) $(ARFLAGS) $@ $(OBJECTS)
+libaenet.a : $(OBJECTS) Makefile.inc 
+	$(AR) $(ARFLAGS)  $@ $(OBJECTS) 
 
-libaenet.so : $(PICOBJECTS) Makefile.inc
-	$(LIBLD) $(LIBFLAGS) $(PICOBJECTS) $(LIBLIB) -o $@
+#libaenet.so : $(PICOBJECTS) Makefile.inc
+#	$(LIBLD) $(LIBFLAGS)  $(PICOBJECTS) $(LIBLIB) -o $@
 
 veryclean: clean
 	for f in $(TARGETS); do rm -f $$f-*; done
@@ -127,3 +131,4 @@
 sfsetup.o     : aeio.o io.o sfbasis.o symmfunc.o
 trainset.o    : aeio.o io.o sfsetup.o
 xsflib.o      : io.o
+trainset_MPI.o    : aeio.o io.o sfsetup.o trainset.o
diff -Naru src/aenet.f90 src_modified/aenet.f90
--- src/aenet.f90	2025-04-08 11:32:06.108110077 +0900
+++ src_modified/aenet.f90	2025-04-08 13:27:27.570785732 +0900
@@ -139,6 +139,8 @@
 
     integer :: ok
 
+    
+
     stat = AENET_OK
     if (aenet_is_init) then
        stat = AENET_ERR_INIT
@@ -403,8 +405,8 @@
 
   subroutine aenet_atomic_energy_and_forces( &
        coo_i, type_i, index_i, n_j, coo_j, type_j, index_j, natoms, &
-       E_i, F, stat) bind(C)
-
+       E_i, F, S, stat) bind(C)
+    !coo_i, type_i, iatom, nnb, nbcoo, nbtype, nblist, nAtoms, E_i, forCart, stat
     implicit none
 
     real(kind=c_double), dimension(3),        intent(in)    :: coo_i
@@ -417,6 +419,7 @@
     integer(kind=c_int), value,               intent(in)    :: natoms
     real(kind=c_double),                      intent(out)   :: E_i
     real(kind=c_double), dimension(3,natoms), intent(inout) :: F
+    real(kind=c_double), dimension(3,3), intent(inout) :: S
     integer(kind=c_int),                      intent(out)   :: stat
 
     double precision, dimension(1)                  :: E_i_arr
@@ -430,6 +433,7 @@
     integer                                         :: nsf, j
     double precision, dimension(:),     allocatable :: dE_dG
     integer                                         :: ok
+    integer                                         :: x1,x2,d
 
     stat = AENET_OK
     if (.not. (aenet_is_init .and. aenet_is_loaded)) then
@@ -473,6 +477,19 @@
                           * matmul(sfderiv_j(1:3,1:nsf,j), dE_dG(1:nsf))
     end do
 
+    !stress tensor
+    do x1=1,3
+       do x2 = x1,3
+          do j =1, n_j
+             do d = 1, nsf
+                S(x2,x1) = S(x2,x1) + (coo_i(x2)-coo_j(x2,j))*aenet_pot(type_i)%E_scale&
+                     * sfderiv_j(x1,d,j)*dE_dG(d)
+             end do
+          end do
+       end do
+    end do
+
+
     deallocate(dE_dG, sfval, sfderiv_i, sfderiv_j, &
                values, derivs, jacobian, stat=ok)
     if (ok /= 0) then
diff -Naru src/aenet.h src_modified/aenet.h
--- src/aenet.h	2025-04-08 11:32:06.108110077 +0900
+++ src_modified/aenet.h	2025-04-08 13:27:27.570785732 +0900
@@ -16,7 +16,7 @@
 void aenet_atomic_energy_and_forces(double coo_i[3], int type_i, int index_i,
                                     int n_j, double coo_j[], int type_j[],
                                     int index_j[], int natoms, double* E_i,
-                                    double F[], int* stat);
+                                    double F[], double S[], int* stat);
 
 void aenet_convert_atom_types(int ntypes_in, char* atom_types[],
                               int natoms_in, int type_id_in[],
diff -Naru src/aenet_generate.F90 src_modified/aenet_generate.F90
--- src/aenet_generate.F90	1970-01-01 09:00:00.000000000 +0900
+++ src_modified/aenet_generate.F90	2025-04-08 13:27:27.570785732 +0900
@@ -0,0 +1,466 @@
+!-----------------------------------------------------------------------
+!      generate.f90 - generate training sets for use with train.x
+!-----------------------------------------------------------------------
+!+ This file is part of the AENET package.
+!+
+!+ Copyright (C) 2012-2018 Nongnuch Artrith and Alexander Urban
+!+
+!+ This Source Code Form is subject to the terms of the Mozilla Public
+!+ License, v. 2.0. If a copy of the MPL was not distributed with this
+!+ file, You can obtain one at http://mozilla.org/MPL/2.0/.
+!+
+!+ This program is distributed in the hope that it will be useful, but
+!+ WITHOUT ANY WARRANTY; without even the implied warranty of
+!+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+!+ Mozilla Public License, v. 2.0, for more details.
+!-----------------------------------------------------------------------
+! 2011-10-19 Alexander Urban (AU), Nongnuch Artrith (NA)
+!-----------------------------------------------------------------------
+
+subroutine generate_sub(inFile,ionum)
+
+  use aeio,     only: aeio_readline,        &
+                      aeio_header,          &
+                      aeio_timestamp,       &
+                      aeio_print_copyright, &
+                      PATHLEN, LINELEN
+
+  use geometry, only: geo_init,          &
+                      geo_final,         &
+                      geo_itype_of_name, &
+                      geo_type_conv,     &
+                      pbc,               &
+                      latticeVec,        &
+                      nAtoms,            &
+                      nTypes,            &
+                      atomType,          &
+                      atomTypeName,      &
+                      cooLatt,           &
+                      cooCart,           &
+                      forCart,           &
+                      hasEnergy,         &
+                      hasForces,         &
+                      cohesiveEnergy,    &
+                      totalEnergy
+
+  use input,    only: InputData,         &
+                      read_InpGenerate,  &
+                      del_InputData
+
+  use io,       only: io_adjustl,        &
+                      io_center,         &
+                      io_lower,          &
+                      io_readnext,       &
+                      io_unit
+
+  use lclist,   only: lcl_init,          &
+                      lcl_final,         &
+                      lcl_print_info,    &
+                      lcl_nmax_nbdist,   &
+                      lcl_nbdist_cart
+
+  use sfsetup,  only: Setup,                 &
+                      read_Setup_parameters, &
+                      save_Setup,            &
+                      del_Setup,             &
+                      stp_init,              &
+                      stp_final,             &
+                      stp_get_range,         &
+                      stp_print_info,        &
+                      stp_eval,              &
+                      nsf_max
+
+  use timing,   only: tng_init,          &
+                      tng_final,         &
+                      tng_timing,        &
+                      tng_timing2,       &
+                      tng_timing3,       &
+                      tng_dump
+
+  use trainset, only: TrnSet,                 &
+                      new_TrnSet,             &
+                      close_TrnSet,           &
+                      ts_print_info,          &
+                      ts_write_header,        &
+                      ts_write_sf_info,       &
+                      ts_write_atom_info,     &
+                      ts_write_structure_info
+
+  implicit none
+
+  !--------------------------------------------------------------------!
+  ! stp(i)         structural fingerprint basis setup for atom type i  !
+  ! r_min, r_max   lower and upper bound for atomic interactions       !
+  ! ts             training set reference                              !
+  !                                                                    !
+  ! nnb_max, nnb   max. and actual number of neighboring atoms         !
+  ! nbcoo(i,j)     i-th component of the coordinates of the j-th       !
+  !                neighboring atom                                    !
+  ! nbdist(i)      distance of the i-th neighbor                       !
+  !                                                                    !
+  ! sfval(i)         value of the i-th basis function                  !
+  ! sfderiv_i(i,j)   i-th component of the derivative of the j-th SF   !
+  !                  with respect to the central atom                  !
+  !                  sfderiv_i(3,nsf_max)                              !
+  ! sfderiv_j(i,j,k) i-th component of the derivative of the j-th SF   !
+  !                  with respect to the coordinates of atom k         !
+  !                  sfderiv_j(3,nsf_max,nnb_max)                      !
+  !                                                                    !
+  ! E_coh          cohesive energy                                     !
+  ! nFiles_inv     = 1/inp%nStrucs                                     !
+  !                                                                    !
+  ! inFile         name of the input file for the generate.x program   !
+  ! cooFile        name of the currently active structure file         !
+  ! keyword        the last keyword read from the input file           !
+  !                                                                    !
+  ! do_debug       if .true., additional files containing debugging    !
+  !                info will be created                                !
+  !                                                                    !
+  ! u_*            file units                                          !
+  !--------------------------------------------------------------------!
+
+  type(InputData)                                :: inp
+
+  type(Setup),       dimension(:),   allocatable :: stp
+  double precision                               :: r_min, r_max
+  type(TrnSet)                                   :: ts
+
+  integer                                        :: nnb_max, nnb
+  double precision,  dimension(:,:), allocatable :: nbcoo
+  double precision,  dimension(:),   allocatable :: nbdist
+  integer,           dimension(:),   allocatable :: nbtype
+
+  double precision, dimension(:),     allocatable :: sfval
+  double precision, dimension(:,:),   allocatable :: sfderiv_i
+  double precision, dimension(:,:,:), allocatable :: sfderiv_j
+
+  double precision                               :: E_coh
+  integer                                        :: ifile
+  double precision                               :: nFiles_inv
+
+
+  character(len=*),intent(in)                    :: inFile
+  integer,intent(in)                             ::ionum
+
+  character(len=PATHLEN)                         :: cooFile
+  character(len=LINELEN)                         :: keyword
+
+  integer                                        :: itype1
+  integer                                        :: itype, iatom
+
+  integer                                        :: iline
+  character(len=1024)                            :: line
+
+  integer                                        :: u_in, u_tng
+  logical                                        :: do_debug = .false.
+  integer                                        :: u_dbg, idbg
+
+  integer :: i
+
+  ! timing registers
+  integer, parameter :: R_GEO = 1, R_NBL = 2, R_SF = 3
+
+  !-------------------------- initialization --------------------------!
+
+!  call initialize(inFile)
+
+  inp = read_InpGenerate(inFile)
+  allocate(stp(inp%nTypes))
+  call load_symmfunc_setups(inp, stp)
+
+  ! call parse_input(inFile)
+
+  if (inp%do_timing) then
+     u_tng = io_unit()
+     call tng_init(unit=u_tng, file='generate.time', registers=3)
+     write(ionum,*) 'Timing info will be written to: ', 'generate.time'
+     write(ionum,*)
+  end if
+  if (do_debug) then
+     u_dbg = io_unit()
+     open(u_dbg, file='generate.debug', status='replace', action='write')
+  end if
+
+  ! get interaction range and max. number of atoms within range
+  call stp_get_range(inp%nTypes, stp, r_min, r_max)
+  nnb_max = lcl_nmax_nbdist(r_min, r_max)
+  allocate(nbcoo(3,nnb_max), nbdist(nnb_max), nbtype(nnb_max))
+
+  ! initialize workspace for structural fingerprint basis:
+  call stp_init(inp%nTypes, stp, nnb_max)
+  if (inp%do_timing) call tng_timing('Structural fingerprint basis initialized.')
+
+  ! allocate workspace for basis function evaluation:
+  allocate(sfval(nsf_max), sfderiv_i(3,nsf_max), sfderiv_j(3,nsf_max,nnb_max))
+  sfval(:) = 0.0d0
+  sfderiv_i(:,:) = 0.0d0
+  sfderiv_j(:,:,:) = 0.0d0
+
+!  call aeio_header('Generation of training set started')
+  write(ionum,*)
+
+  write(ionum,*) 'Number of atom types  : ', trim(io_adjustl(inp%nTypes))
+  write(ionum,'(1x,"types                 : ")', advance='no')
+  do itype = 1, inp%nTypes
+     if (mod(itype,7) == 0) write(ionum,'(29x)')
+     write(ionum,'(A5,1x)', advance='no') inp%typeName(itype)
+  end do
+  write(ionum,*)
+  write(ionum,*) "Number of structures  : ", trim(io_adjustl(inp%nStrucs))
+  write(ionum,*)
+
+  !-------------- write basis function settings to stdout -------------!
+
+!  call aeio_header("Structural fingerprint basis set-up")
+  write(ionum,*)
+
+  do itype1 = 1, inp%nTypes
+!     call stp_print_info(stp(itype1))
+  end do
+
+  !----------- write training set header to the output file -----------!
+
+  ts = new_TrnSet(inp%nTypes, inp%typeName, inp%atomicEnergy, &
+                  inp%nStrucs, trim(inp%outFileName))
+
+  if (inp%do_timing) call tng_timing('Training set file started.')
+
+  !------------------ iterate over coordinates files ------------------!
+
+!  call aeio_header("Adding structures to the training set")
+  write(ionum,*)
+
+  u_in = io_unit()
+  open(u_in, file=inFile, status='old', action='read')
+  rewind(u_in)
+
+  iline = 0
+  do
+     ! forward until the FILES keyword:
+     call aeio_readline(u_in, iline, line)
+     read(line,*) keyword
+     if (trim(keyword) == 'FILES') then
+        read(u_in,*)
+        exit
+     end if
+  end do
+
+  ! header for stdout
+  write(ionum,'("#",A6,2x,A6,2x,A6,2x,A15,2x,A)') &
+       'N', 'nAtoms', 'nTypes', 'E/atom', 'structure file (xsf)'
+
+  nFiles_inv = 1.0d0/dble(inp%nStrucs)
+  structures : do ifile = 1, inp%nStrucs
+
+     if (inp%do_timing) call tng_timing('Structure: '// io_adjustl(ifile))
+
+     call aeio_readline(u_in, iline, line)
+     cooFile = trim(line)
+
+     call geo_init(cooFile, 'xsf')
+     if (inp%do_timing) call tng_timing3(register=R_GEO)
+     if (.not. (hasForces .and. hasEnergy)) then
+        write(0,*) ">>>", hasForces, hasEnergy
+        write(0,*) "Error: incomplete output data in : ", trim(cooFile)
+        call finalize()
+        stop
+     end if
+
+     if (nTypes > inp%nTypes) then
+        write(ionum,*) 'Skipping ', trim(adjustl(cooFile)), &
+                   ': too many atomic species'
+        call geo_final()
+        cycle structures
+     end if
+
+     if (abs(cohesiveEnergy) /= 0.0d0) then
+        E_coh = cohesiveEnergy
+     else
+        ! if only the total energy is available, we have to calculate
+        ! the cohesive energy at this point
+        E_coh = totalEnergy
+        do iatom = 1, nAtoms
+           itype1 = atomType(iatom)
+           itype1 = geo_type_conv(itype1, nTypes, atomTypeName, &
+                                  inp%nTypes, inp%typeName)
+           E_coh = E_coh - inp%atomicEnergy(itype1)
+        end do
+     end if
+
+     write(ionum,'(1x,I6,2x,I6,2x,I6,2x,ES15.8,2x,A)') &
+          ifile, nAtoms, nTypes, E_coh/dble(nAtoms), &
+          trim(adjustl(cooFile))
+
+     call lcl_init(r_min, r_max, latticeVec, nAtoms, atomType, cooLatt, pbc)
+     if (inp%do_timing) call tng_timing3(register=R_NBL)
+
+     ! write structure info (atoms, types, energy) to training set file:
+     call ts_write_structure_info(ts, cooFile, nAtoms, nTypes, E_coh)
+
+     atoms : do iatom = 1, nAtoms
+
+        ! determine the training atom type of atom `iatom' in global
+        ! index terms
+        itype1 = atomType(iatom)
+        itype1 = geo_type_conv(itype1, nTypes, atomTypeName, &
+                               inp%nTypes, inp%typeName)
+
+        ! assert that atom type is included in the set-ups:
+        if (itype1 == 0) then
+           write(0,*) "Error: not a valid structure    : ", trim(cooFile)
+           write(0,*) "       Additional species found."
+           call finalize()
+           stop
+        end if
+
+        ! write atom info (species, forces) to training set file:
+        call ts_write_atom_info(ts, itype1, cooCart(iatom), forCart(iatom))
+
+        ! get all atoms within cut-off:
+        nnb = nnb_max
+        call lcl_nbdist_cart(iatom, nnb, nbcoo, nbdist, r_cut=r_max, nbtype=nbtype)
+        if (inp%do_timing) call tng_timing3(register=R_NBL)
+        write(ionum,'(1x,I6,2x,A2,2x,I6)') &
+             iatom, trim(atomTypeName(atomType(iatom))), nnb
+
+        ! convert atom types to global index:
+        do i = 1, nnb
+           nbtype(i) = geo_type_conv(nbtype(i), nTypes, atomTypeName, &
+                                    inp%nTypes, inp%typeName)
+           if (nbtype(i) == 0) then
+              write(0,*) "Error: atom type not found in setup."
+              call finalize()
+              stop
+           end if
+        end do
+
+        ! evaluate the structural fingerprint basis function set-up:
+        call stp_eval(itype1, cooCart(iatom), nnb, nbcoo, nbtype, &
+                      stp(itype1), sfval=sfval)
+
+        if (do_debug) then
+           do idbg = 1, stp(itype1)%nsf
+              write(u_dbg,'(1x,ES15.8,1x)', advance='no') sfval(idbg)
+           end do
+           write(u_dbg,*)
+        end if
+
+        if (inp%do_timing) call tng_timing3(register=R_SF)
+
+        ! write basis function values and derivatives
+        ! to the training set file:
+        call ts_write_sf_info(ts, stp(itype1)%nsf, sfval(1:stp(itype1)%nsf))
+
+     end do atoms
+
+     if (inp%do_timing) then
+        call tng_dump(R_GEO, 'time spent reading geometries (so far)')
+        call tng_dump(R_NBL, 'time spent in the neighbor list (so far)')
+        call tng_dump(R_SF,  'time spent evaluating structural fingerprints (so far)')
+     end if
+
+     call lcl_final()
+     call geo_final()
+
+  end do structures
+  write(ionum,*)
+
+  if (inp%do_timing) then
+     call tng_timing('Loop over structures done.')
+     call tng_dump(R_GEO, 'total time spent reading geometries')
+     call tng_dump(R_NBL, 'total time spent in the neighbor list')
+     call tng_dump(R_SF,  'total time spent evaluating structural fingerprints')
+  end if
+
+  !--------- save basis function setups with final statistics ---------!
+
+!  call ts_print_info(ts)
+
+  !----------------------------- finalize -----------------------------!
+
+  deallocate(nbcoo, nbdist, nbtype)
+  close(u_in)
+
+  call close_TrnSet(ts, stp=stp(1:inp%nTypes))
+  call finalize()
+
+
+contains !=============================================================!
+
+
+
+
+  !--------------------------------------------------------------------!
+
+  subroutine finalize()
+
+    implicit none
+
+    integer :: itype
+
+    if (allocated(sfval)) then
+       deallocate(sfval, sfderiv_i, sfderiv_j)
+    end if
+
+    if (allocated(stp)) then
+       call stp_final(inp%nTypes, stp)
+       do itype = 1, inp%nTypes
+          call del_Setup(stp(itype))
+       end do
+       deallocate(stp, inp%typeName, inp%atomicEnergy)
+    end if
+
+    if (ts%init) call close_TrnSet(ts)
+
+    if (allocated(nbcoo)) deallocate(nbcoo, nbdist)
+
+    if (inp%do_timing) call tng_final()
+    if (do_debug)  close(u_dbg)
+
+    call aeio_header(aeio_timestamp(), char=' ')
+    call aeio_header("Training set generation done.", char='=')
+
+  end subroutine finalize
+
+  !--------------------------------------------------------------------!
+
+  subroutine print_usage()
+
+    implicit none
+
+    write(ionum,*)
+    write(ionum,*) "generate.x -- Generate training sets for use with `train.x'"
+    write(ionum,'(1x,70("-"))')
+    write(ionum,*) 'Usage: generate.x <input-file>'
+    write(ionum,*)
+    write(ionum,*) 'See the documentation or the source code for a description of the '
+    write(ionum,*) 'input file format.'
+    write(ionum,*)
+
+  end subroutine print_usage
+
+  !--------------------------------------------------------------------!
+
+  subroutine load_symmfunc_setups(inp, stp)
+
+    implicit none
+
+    type(InputData),           intent(in)  :: inp
+    type(Setup), dimension(:), intent(out) :: stp
+
+    integer :: i
+
+    do i = 1, inp%nTypes
+       stp(i) = read_Setup_parameters(inp%setupFile(i), inp%typeName(:))
+       if (.not. (trim(stp(i)%atomtype) == trim(inp%typeName(i)))) then
+          write(0,*) "Error: Inconsistent atom type in setup:"
+          write(0,*) "       type expected : ", trim(inp%typeName(i))
+          write(0,*) "       type found    : ", trim(stp(i)%atomtype)
+          call finalize()
+          stop
+       end if
+    end do
+
+  end subroutine load_symmfunc_setups
+
+end subroutine generate_sub
diff -Naru src/aenet_generate_mpi.F90 src_modified/aenet_generate_mpi.F90
--- src/aenet_generate_mpi.F90	1970-01-01 09:00:00.000000000 +0900
+++ src_modified/aenet_generate_mpi.F90	2025-04-08 13:27:27.570785732 +0900
@@ -0,0 +1,651 @@
+!-----------------------------------------------------------------------
+!      generate.f90 - generate training sets for use with train.x
+!-----------------------------------------------------------------------
+!+ This file is part of the AENET package.
+!+
+!+ Copyright (C) 2012-2018 Nongnuch Artrith and Alexander Urban
+!+
+!+ This Source Code Form is subject to the terms of the Mozilla Public
+!+ License, v. 2.0. If a copy of the MPL was not distributed with this
+!+ file, You can obtain one at http://mozilla.org/MPL/2.0/.
+!+
+!+ This program is distributed in the hope that it will be useful, but
+!+ WITHOUT ANY WARRANTY; without even the implied warranty of
+!+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+!+ Mozilla Public License, v. 2.0, for more details.
+!-----------------------------------------------------------------------
+! 2011-10-19 Alexander Urban (AU), Nongnuch Artrith (NA)
+!-----------------------------------------------------------------------
+
+subroutine generate_sub_mpi(inFile,ionum)
+
+  use aeio,     only: aeio_readline,        &
+                      aeio_header,          &
+                      aeio_timestamp,       &
+                      aeio_print_copyright, &
+                      PATHLEN, LINELEN
+
+  use geometry, only: geo_init,          &
+                      geo_final,         &
+                      geo_itype_of_name, &
+                      geo_type_conv,     &
+                      pbc,               &
+                      latticeVec,        &
+                      nAtoms,            &
+                      nTypes,            &
+                      atomType,          &
+                      atomTypeName,      &
+                      cooLatt,           &
+                      cooCart,           &
+                      forCart,           &
+                      hasEnergy,         &
+                      hasForces,         &
+                      cohesiveEnergy,    &
+                      totalEnergy
+
+  use input,    only: InputData,         &
+                      read_InpGenerate,  &
+                      del_InputData
+
+  use io,       only: io_adjustl,        &
+                      io_center,         &
+                      io_lower,          &
+                      io_readnext,       &
+                      io_unit
+
+  use lclist,   only: lcl_init,          &
+                      lcl_final,         &
+                      lcl_print_info,    &
+                      lcl_nmax_nbdist,   &
+                      lcl_nbdist_cart
+
+  use sfsetup,  only: Setup,                 &
+                      read_Setup_parameters, &
+                      save_Setup,            &
+                      del_Setup,             &
+                      stp_init,              &
+                      stp_final,             &
+                      stp_get_range,         &
+                      stp_print_info,        &
+                      stp_eval,              &
+                      nsf_max
+
+  use timing,   only: tng_init,          &
+                      tng_final,         &
+                      tng_timing,        &
+                      tng_timing2,       &
+                      tng_timing3,       &
+                      tng_dump
+
+  use trainset, only: TrnSet,                     &
+                      ts_print_info
+
+  use trainset_MPI, only: new_TrnSet_MPI,             &
+                          close_TrnSet_MPI,           &
+                          ts_write_header_MPI,        &
+                          ts_write_sf_info_MPI,       &
+                          ts_write_atom_info_MPI,     &
+                          ts_write_structure_info_MPI,&
+                          ts_parallel_footer_MPI,&
+                          ts_loadandwrite_structure_info_MPI
+
+  use parallel,    only: pp_init,                &
+                         pp_final,               &
+                         pp_bcast,               &
+                         pp_barrier,             &
+                         ppMaster,               &
+                         ppRank,                 &
+                         ppSize,                 &
+                         pp_bcast_InputData,     &
+                         pp_bcast_Setup
+
+  implicit none
+
+  !--------------------------------------------------------------------!
+  ! stp(i)         structural fingerprint basis setup for atom type i  !
+  ! r_min, r_max   lower and upper bound for atomic interactions       !
+  ! ts             training set reference                              !
+  !                                                                    !
+  ! nnb_max, nnb   max. and actual number of neighboring atoms         !
+  ! nbcoo(i,j)     i-th component of the coordinates of the j-th       !
+  !                neighboring atom                                    !
+  ! nbdist(i)      distance of the i-th neighbor                       !
+  !                                                                    !
+  ! sfval(i)         value of the i-th basis function                  !
+  ! sfderiv_i(i,j)   i-th component of the derivative of the j-th SF   !
+  !                  with respect to the central atom                  !
+  !                  sfderiv_i(3,nsf_max)                              !
+  ! sfderiv_j(i,j,k) i-th component of the derivative of the j-th SF   !
+  !                  with respect to the coordinates of atom k         !
+  !                  sfderiv_j(3,nsf_max,nnb_max)                      !
+  !                                                                    !
+  ! E_coh          cohesive energy                                     !
+  ! nFiles_inv     = 1/inp%nStrucs                                     !
+  !                                                                    !
+  ! inFile         name of the input file for the generate.x program   !
+  ! cooFile        name of the currently active structure file         !
+  ! keyword        the last keyword read from the input file           !
+  !                                                                    !
+  ! do_debug       if .true., additional files containing debugging    !
+  !                info will be created                                !
+  !                                                                    !
+  ! u_*            file units                                          !
+  !--------------------------------------------------------------------!
+
+  type(InputData)                                :: inp
+
+  type(Setup),       dimension(:),   allocatable :: stp
+  double precision                               :: r_min, r_max
+  type(TrnSet)                                   :: ts
+
+  integer                                        :: nnb_max, nnb
+  double precision,  dimension(:,:), allocatable :: nbcoo
+  double precision,  dimension(:),   allocatable :: nbdist
+  integer,           dimension(:),   allocatable :: nbtype
+
+  double precision, dimension(:),     allocatable :: sfval
+  double precision, dimension(:,:),   allocatable :: sfderiv_i
+  double precision, dimension(:,:,:), allocatable :: sfderiv_j
+
+  double precision                               :: E_coh
+  integer                                        :: ifile
+  double precision                               :: nFiles_inv
+
+  character(len=*),intent(in)                    :: inFile
+  integer,intent(in)                             :: ionum
+
+
+  character(len=PATHLEN)                         :: cooFile
+  character(len=LINELEN)                         :: keyword
+
+  integer                                        :: itype1
+  integer                                        :: itype, iatom
+
+  integer                                        :: iline
+  character(len=1024)                            :: line
+
+  integer                                        :: u_in, u_tng
+  logical                                        :: do_debug = .false.
+  integer                                        :: u_dbg, idbg
+
+  integer :: i, j, l
+  logical :: lexist
+
+  ! timing registers
+  integer, parameter :: R_GEO = 1, R_NBL = 2, R_SF = 3
+
+  logical :: stopnow
+  character(len=262144)                           :: longline
+
+  integer rename, status
+   
+
+  !-------------------------- initialization --------------------------!
+
+  if (ppMaster) then
+     call system( 'rm -f ts.* 2> /dev/null' )
+  end if
+
+  call initialize_MPI()
+
+  if (ppMaster) inp = read_InpGenerate(inFile)
+  call pp_bcast_InputData(inp)
+!  inp = read_InpGenerate(inFile)
+
+  
+
+  allocate(stp(inp%nTypes))
+  call load_symmfunc_setups_MPI(inp, stp)
+  ! call parse_input(inFile)
+  
+  
+
+  if (inp%do_timing .and. ppMaster ) then
+     u_tng = io_unit()
+     call tng_init(unit=u_tng, file='generate.time', registers=3)
+     write(ionum,*) 'Timing info will be written to: ', 'generate.time'
+     write(ionum,*)
+  end if
+  if (do_debug .and. ppMaster ) then
+     u_dbg = io_unit()
+     open(u_dbg, file='generate.debug', status='replace', action='write')
+  end if
+
+  
+
+  ! get interaction range and max. number of atoms within range
+  call stp_get_range(inp%nTypes, stp, r_min, r_max)
+  nnb_max = lcl_nmax_nbdist(r_min, r_max)
+  allocate(nbcoo(3,nnb_max), nbdist(nnb_max), nbtype(nnb_max))
+
+  ! initialize workspace for structural fingerprint basis:
+  call stp_init(inp%nTypes, stp, nnb_max)
+  if (inp%do_timing .and. ppMaster) call tng_timing('Structural fingerprint basis initialized.')
+
+  ! allocate workspace for basis function evaluation:
+  allocate(sfval(nsf_max), sfderiv_i(3,nsf_max), sfderiv_j(3,nsf_max,nnb_max))
+  sfval(:) = 0.0d0
+  sfderiv_i(:,:) = 0.0d0
+  sfderiv_j(:,:,:) = 0.0d0
+  
+
+  if (ppMaster) then
+     call aeio_header('Generation of training set started')
+     write(ionum,*)
+
+     write(ionum,*) 'Number of atom types  : ', trim(io_adjustl(inp%nTypes))
+     write(ionum,'(1x,"types                 : ")', advance='no')
+     do itype = 1, inp%nTypes
+        if (mod(itype,7) == 0) write(ionum,'(29x)')
+        write(ionum,'(A5,1x)', advance='no') inp%typeName(itype)
+     end do
+     write(ionum,*)
+     write(ionum,*) "Number of structures  : ", trim(io_adjustl(inp%nStrucs))
+     write(ionum,*)
+  end if
+
+  !-------------- write basis function settings to stdout -------------!
+
+  if (ppMaster) then
+     call aeio_header("Structural fingerprint basis set-up")
+     write(ionum,*)
+
+     do itype1 = 1, inp%nTypes
+        call stp_print_info(stp(itype1))
+     end do
+  end if
+
+  !----------- write training set header to the output file -----------!
+
+  ts = new_TrnSet_MPI(inp%nTypes, inp%typeName, inp%atomicEnergy, &
+                      inp%nStrucs, trim(inp%outFileName))
+
+  if (inp%do_timing .and. ppMaster) call tng_timing('Training set file started.')
+
+  !------------------ iterate over coordinates files ------------------!
+
+  if (ppMaster) then
+     call aeio_header("Adding structures to the training set")
+     write(ionum,*)
+  end if
+
+  u_in = io_unit()
+  open(u_in, file=inFile, status='old', action='read')
+  rewind(u_in)
+
+  iline = 0
+  do
+     ! forward until the FILES keyword:
+     call aeio_readline(u_in, iline, line)
+     read(line,*) keyword
+     if (trim(keyword) == 'FILES') then
+        read(u_in,*)
+        exit
+     end if
+  end do
+
+  ! header for stdout
+  if (ppMaster) then
+     write(ionum,'("#",A6,2x,A6,2x,A6,2x,A15,2x,A)') &
+          'N', 'nAtoms', 'nTypes', 'E/atom', 'structure file (xsf)'
+  end if
+
+  stopnow = .false.
+
+  nFiles_inv = 1.0d0/dble(inp%nStrucs)
+  structures : do ifile = 1, inp%nStrucs
+
+     if (inp%do_timing .and. ppMaster) call tng_timing('Structure: '// io_adjustl(ifile))
+
+     call aeio_readline(u_in, iline, line)
+     cooFile = trim(line)
+
+     if ( mod(ifile-1,ppSize) .ne. ppRank ) cycle
+
+     call geo_init(cooFile, 'xsf')
+     if (inp%do_timing) call tng_timing3(register=R_GEO)
+     if (.not. (hasForces .and. hasEnergy)) then
+        write(0,*) ">>>", hasForces, hasEnergy
+        write(0,*) "Error: incomplete output data in : ", trim(cooFile)
+        stop
+!        stopnow = .true.
+     end if
+
+!     call pp_bcast(stopnow)
+!     if (stopnow) then!
+!!       call finalize_MPI()
+!        stop
+!     end if
+
+     if (nTypes > inp%nTypes) then
+        if (ppMaster) then
+           write(ionum,*) 'Skipping ', trim(adjustl(cooFile)), &
+                   ': too many atomic species'
+        end if
+        call geo_final()
+        cycle structures
+     end if
+
+     if (abs(cohesiveEnergy) /= 0.0d0) then
+        E_coh = cohesiveEnergy
+     else
+        ! if only the total energy is available, we have to calculate
+        ! the cohesive energy at this point
+        E_coh = totalEnergy
+        do iatom = 1, nAtoms
+           itype1 = atomType(iatom)
+           itype1 = geo_type_conv(itype1, nTypes, atomTypeName, &
+                                  inp%nTypes, inp%typeName)
+           E_coh = E_coh - inp%atomicEnergy(itype1)
+        end do
+     end if
+
+     if (ppMaster) then
+       write(ionum,'(1x,I6,2x,I6,2x,I6,2x,ES15.8,2x,A)') &
+         ifile, nAtoms, nTypes, E_coh/dble(nAtoms), &
+         trim(adjustl(cooFile))
+     end if
+
+     call lcl_init(r_min, r_max, latticeVec, nAtoms, atomType, cooLatt, pbc)
+     if (inp%do_timing .and. ppMaster) call tng_timing3(register=R_NBL)
+
+     ! write structure info (atoms, types, energy) to training set file:
+     call ts_write_structure_info_MPI(ts, cooFile, nAtoms, nTypes, E_coh, ifile)
+
+     atoms : do iatom = 1, nAtoms
+
+        ! determine the training atom type of atom `iatom' in global
+        ! index terms
+        itype1 = atomType(iatom)
+        itype1 = geo_type_conv(itype1, nTypes, atomTypeName, &
+                               inp%nTypes, inp%typeName)
+
+        ! assert that atom type is included in the set-ups:
+        if (itype1 == 0) then
+           write(0,*) "Error: not a valid structure    : ", trim(cooFile)
+           write(0,*) "       Additional species found."
+           !call finalize_MPI()
+           stop
+        end if
+
+        ! write atom info (species, forces) to training set file:
+        call ts_write_atom_info_MPI(ts, itype1, cooCart(iatom), forCart(iatom), ifile)
+
+        ! get all atoms within cut-off:
+        nnb = nnb_max
+        call lcl_nbdist_cart(iatom, nnb, nbcoo, nbdist, r_cut=r_max, nbtype=nbtype)
+        if (inp%do_timing .and. ppMaster) call tng_timing3(register=R_NBL)
+!        write(ionum,'(1x,I6,2x,A2,2x,I6)') &
+!             iatom, trim(atomTypeName(atomType(iatom))), nnb
+
+        ! convert atom types to global index:
+        do i = 1, nnb
+           nbtype(i) = geo_type_conv(nbtype(i), nTypes, atomTypeName, &
+                                    inp%nTypes, inp%typeName)
+           if (nbtype(i) == 0) then
+              write(0,*) "Error: atom type not found in setup."
+              call finalize_MPI()
+              stop
+           end if
+        end do
+
+        ! evaluate the structural fingerprint basis function set-up:
+        call stp_eval(itype1, cooCart(iatom), nnb, nbcoo, nbtype, &
+                      stp(itype1), sfval=sfval)
+
+        if (do_debug .and. ppMaster) then
+           do idbg = 1, stp(itype1)%nsf
+              write(u_dbg,'(1x,ES15.8,1x)', advance='no') sfval(idbg)
+           end do
+           write(u_dbg,*)
+        end if
+
+        if (inp%do_timing .and. ppMaster) call tng_timing3(register=R_SF)
+
+        ! write basis function values and derivatives
+        ! to the training set file:
+        call ts_write_sf_info_MPI(ts, stp(itype1)%nsf, sfval(1:stp(itype1)%nsf), ifile)
+
+     end do atoms
+
+     if (inp%do_timing .and. ppMaster) then
+        call tng_dump(R_GEO, 'time spent reading geometries (so far)')
+        call tng_dump(R_NBL, 'time spent in the neighbor list (so far)')
+        call tng_dump(R_SF,  'time spent evaluating structural fingerprints (so far)')
+     end if
+
+     call lcl_final()
+     call geo_final()
+
+  end do structures
+  if (ppMaster) write(ionum,*)
+
+  if (inp%do_timing) then
+     call tng_timing('Loop over structures done.')
+     call tng_dump(R_GEO, 'total time spent reading geometries')
+     call tng_dump(R_NBL, 'total time spent in the neighbor list')
+     call tng_dump(R_SF,  'total time spent evaluating structural fingerprints')
+  end if
+
+  !--------- save basis function setups with final statistics ---------!
+
+  if (ppMaster) call ts_print_info(ts)
+
+  !----------------------------- finalize -----------------------------!
+
+  deallocate(nbcoo, nbdist, nbtype)
+  close(u_in)
+
+  call pp_barrier()
+
+  if (ppMaster) then
+   do ifile = 1, inp%nStrucs
+      call ts_loadandwrite_structure_info_MPI(ifile)
+   end do
+  end if
+
+  call ts_parallel_footer_MPI(ts, stp)
+
+
+  
+
+  call close_TrnSet_MPI(ts, stp=stp(1:inp%nTypes))
+
+
+
+  l = 5000
+  call pp_barrier()
+  if (ppMaster) then
+   status = rename( "ts.all",adjustl(trim(inp%outFileName))) !rename the file
+      do ifile = 1, inp%nStrucs
+         open(10001, file='ts.'//io_adjustl(ifile))
+         close(10001, status="delete")
+      end do
+  end if
+
+  call pp_barrier()
+  call finalize_MPI()
+  return
+
+  do j = 1, 5
+    if (ppMaster) then
+      write(ionum,*) 'cat started.'
+      do ifile = 1, inp%nStrucs, l
+        write(ionum,*) 'cat files ' // trim(io_adjustl(ifile)) // ' to ' &
+ &                        // trim(io_adjustl(min(ifile-1+l,inp%nStrucs)))
+        longline = 'cat'
+        if ( ifile .eq. 1 ) longline = trim(longline) // ' ts.header'
+        do i = ifile, min(ifile-1+l,inp%nStrucs)
+           longline = trim(longline) // ' ts.' // trim(io_adjustl(i))
+        end do
+        if ( ifile .ge. inp%nStrucs-l+1 ) longline = trim(longline) // ' ts.footer'
+        if ( ifile .eq. 1 ) then
+          longline = trim(longline) // ' > ' // adjustl(trim(inp%outFileName))
+        else
+          longline = trim(longline) // ' >> ' // adjustl(trim(inp%outFileName))
+        end if
+        write(ionum,*) trim(longline)
+        call system( trim(longline) )
+      end do
+      write(ionum,*) 'cat ended.'
+      inquire ( file=adjustl(trim(inp%outFileName)), exist=lexist )
+      if ( lexist ) then
+        write(ionum,*) adjustl(trim(inp%outFileName)) // ' found.'
+        call system( 'rm -f ts.* 2> /dev/null' )
+        exit
+      else
+        write(ionum,*) adjustl(trim(inp%outFileName)) // ' missing.'
+        call system( 'sleep 1.0' )
+      end if
+    end if
+  end do
+  call pp_barrier()
+
+  call finalize_MPI()
+
+
+
+contains !=============================================================!
+
+
+  subroutine initialize_MPI()
+
+    implicit none
+
+!    character(len=*), intent(out) :: inFile
+
+    integer :: nargs
+    logical :: fexists
+    logical :: stopnow
+
+    call pp_init()
+
+!    stopnow = .false.
+
+    if (ppMaster) then
+
+       call aeio_header("generate.x - training set generation", char='=')
+       write(ionum,*)
+
+       call aeio_print_copyright('2015-2018', 'Nongnuch Artrith and Alexander Urban')
+
+!       nargs = command_argument_count()
+!       if (nargs < 1) then
+!          write(0,*) "Error: No input file provided."
+!          call print_usage()
+!          stopnow = .true.
+!       end if
+
+!       call get_command_argument(1, value=inFile)
+!       inquire(file=trim(inFile), exist=fexists)
+!       if (.not. fexists) then
+!          write(0,*) "Error: File not found: ", trim(inFile)
+!          stopnow = .true.
+!       end if
+
+   end if
+!   stopnow = .true.
+
+!    call pp_bcast(stopnow)
+!    if (stopnow) then
+!       call finalize_MPI()
+!       stop
+!    end if
+
+   ! call pp_bcast(inFile)
+
+  end subroutine initialize_MPI
+
+  !--------------------------------------------------------------------!
+
+  subroutine finalize_MPI()
+
+    implicit none
+
+    integer :: itype
+
+    if (allocated(sfval)) then
+       deallocate(sfval, sfderiv_i, sfderiv_j)
+    end if
+
+    if (allocated(stp)) then
+       call stp_final(inp%nTypes, stp)
+       do itype = 1, inp%nTypes
+          call del_Setup(stp(itype))
+       end do
+       deallocate(stp, inp%typeName, inp%atomicEnergy)
+    end if
+
+    if (ts%init) call close_TrnSet_MPI(ts)
+
+    if (allocated(nbcoo)) deallocate(nbcoo, nbdist)
+
+    if (inp%do_timing .and. ppMaster ) call tng_final()
+    if (do_debug .and. ppMaster )  close(u_dbg)
+
+    if (ppMaster) then
+       call aeio_header(aeio_timestamp(), char=' ')
+       call aeio_header("Training set generation done.", char='=')
+    end if
+
+    call pp_final()
+
+  end subroutine finalize_MPI
+
+  !--------------------------------------------------------------------!
+
+  subroutine print_usage()
+
+    implicit none
+
+    write(ionum,*)
+    write(ionum,*) "generate.x -- Generate training sets for use with `train.x'"
+    write(ionum,'(1x,70("-"))')
+    write(ionum,*) 'Usage: generate.x <input-file>'
+    write(ionum,*)
+    write(ionum,*) 'See the documentation or the source code for a description of the '
+    write(ionum,*) 'input file format.'
+    write(ionum,*)
+
+  end subroutine print_usage
+
+  !--------------------------------------------------------------------!
+
+  subroutine load_symmfunc_setups_MPI(inp, stp)
+
+    implicit none
+
+    type(InputData),           intent(in)  :: inp
+    type(Setup), dimension(:), intent(out) :: stp
+    logical :: stopnow
+    integer :: i
+
+    stopnow = .false.
+    
+   
+    if(ppMaster) then 
+      do i = 1, inp%nTypes
+         stp(i) = read_Setup_parameters(inp%setupFile(i), inp%typeName(:))
+         if (.not. (trim(stp(i)%atomtype) == trim(inp%typeName(i)))) then
+            write(0,*) "Error: Inconsistent atom type in setup:"
+            write(0,*) "       type expected : ", trim(inp%typeName(i))
+            write(0,*) "       type found    : ", trim(stp(i)%atomtype)
+            stopnow = .true.
+         end if
+      end do
+   end if
+   
+
+   do i = 1, inp%nTypes
+      call pp_bcast_Setup(stp(i))
+   end do
+
+    call pp_bcast(stopnow)
+    if (stopnow) then
+       call finalize_MPI()
+       stop
+    end if
+
+  end subroutine load_symmfunc_setups_MPI
+
+end subroutine generate_sub_mpi
diff -Naru src/aenet_predict.F90 src_modified/aenet_predict.F90
--- src/aenet_predict.F90	1970-01-01 09:00:00.000000000 +0900
+++ src_modified/aenet_predict.F90	2025-04-08 13:27:27.571785759 +0900
@@ -0,0 +1,791 @@
+!-----------------------------------------------------------------------
+!       predict.f90 - predict atomic energies of input structure
+!-----------------------------------------------------------------------
+!+ This file is part of the AENET package.
+!+
+!+ Copyright (C) 2012-2018 Nongnuch Artrith and Alexander Urban
+!+
+!+ This Source Code Form is subject to the terms of the Mozilla Public
+!+ License, v. 2.0. If a copy of the MPL was not distributed with this
+!+ file, You can obtain one at http://mozilla.org/MPL/2.0/.
+!+
+!+ This program is distributed in the hope that it will be useful, but
+!+ WITHOUT ANY WARRANTY; without even the implied warranty of
+!+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+!+ Mozilla Public License, v. 2.0, for more details.
+!-----------------------------------------------------------------------
+! 2011-11-17 Alexander Urban (AU), Nongnuch Artrith (NA)
+!-----------------------------------------------------------------------
+
+subroutine predict_sub(inFile,ionum,Etot_vec,forCart_vec,stress_vec,mAtoms,mStrucs)
+
+   use aeio,      only: aeio_header,                    &
+                        aeio_timestamp,                 &
+                        aeio_print_copyright
+ 
+   use aenet,     only: aenet_init,                     &
+                        aenet_final,                    &
+                        aenet_atomic_energy,            &
+                        aenet_atomic_energy_and_forces, &
+                        aenet_convert_atom_types,       &
+                        aenet_free_atom_energy,         &
+                        aenet_load_potential,           &
+                        aenet_print_info,               &
+                        aenet_Rc_min, aenet_Rc_max,     &
+                        aenet_nnb_max
+ 
+   use constants, only: PI
+ 
+   use geometry,  only: geo_init,                       &
+                        geo_final,                      &
+                        pbc,                            &
+                        latticeVec,                     &
+                        recLattVec,                     &
+                        geo_update_bounds,              &
+                        origin,                         &
+                        nAtoms,                         &
+                        nTypes,                         &
+                        atomType,                       &
+                        atomTypeName,                   &
+                        cooLatt
+ 
+   use input,     only: InputData,                      &
+                        read_InpPredict,del_InputData
+ 
+   use io,        only: io_adjustl
+ 
+   use lclist,    only: lcl_init,                       &
+                        lcl_final,                      &
+                        lcl_nmax_nbdist,                &
+                        lcl_nbdist_cart
+ 
+   use optimize,  only: opt_init,                       &
+                        opt_final,                      &
+                        opt_optimize_coords
+ 
+   use parallel,  only: pp_init,                        &
+                        pp_final,                       &
+                        pp_bcast,                       &
+                        pp_bcast_coo,                   &
+                        pp_print_info,                  &
+                        pp_bcast_InputData,             &
+                        pp_bcast_latt,                  &
+                        pp_sum,                         &
+                        ppMaster, ppRank, ppSize
+ 
+   implicit none
+ 
+   !--------------------------------------------------------------------!
+   ! A '*' in front of the variable name means that it is a broadcasted !
+   ! variable and has the same value on each process.  A '+' means that !
+   ! an array is allocated on all parallel processes, but does not      !
+   ! necessarily have the same contents.                                !
+   !                                                                    !
+   !----------------------------- general ------------------------------!
+   ! inp             structure with input data                          !
+   ! inFile          name of the input file                             !
+   !                                                                    !
+   !---------------------------- structures ----------------------------!
+   !*nFiles          number of input files/structures                   !
+   ! cooFile         file name of structure file (atomic coordinates)   !
+   !                                                                    !
+   !------------------------------ output ------------------------------!
+   ! Ecoh            cohesive energy of the current structure           !
+   ! Etot            total energy                                       !
+   !+forCart         cartesian atomic forces of the current structure   !
+   !+atomicEnergy    energy of the individual atoms in the structure    !
+   !--------------------------------------------------------------------!
+ 
+   type(InputData)                               :: inp
+
+   character(len=*),intent(in)                           :: inFile
+   character(len=1024)                           ::cooFile, strucFile
+ 
+   integer,          dimension(:),   allocatable :: atomType_orig
+ 
+   integer                                       :: istruc, nStrucs
+   integer, intent(in)                           :: mAtoms, mStrucs
+
+   double precision                              :: Ecoh, Etot, E0
+   double precision, dimension(:,:), allocatable :: forCart
+   double precision, dimension(:,:), allocatable :: stress
+   double precision, dimension(:),   allocatable :: atomicEnergy
+   double precision, intent(out) :: Etot_vec(mStrucs)
+   double precision, intent(out) :: forCart_vec(3,mAtoms,mStrucs)
+   double precision, intent(out) :: stress_vec(3,3,mStrucs)
+ 
+   double precision, dimension(3)                :: F_mav, F_max, F_avg
+   double precision                              :: F_rms, F_rms_prev
+   double precision, dimension(3)                :: dmax
+   integer                                       :: imax
+ 
+   integer                                       :: iter, stat
+   logical                                       :: conv
+
+   integer,intent(in)::ionum
+ 
+ 
+   !-------------------------- initialization --------------------------!
+   call initialize(inFile, strucFile, inp)
+ 
+   !if (ppMaster .and. (inp%verbosity > 0)) call aenet_print_info()
+ 
+   ! number of structures to calculate
+   if (len_trim(strucFile)>0) then
+      nStrucs = 1
+   else
+      if (inp%nStrucs <= 0) then
+         if (ppMaster) then
+            write(0,*) "Error: no input structures specified in ", &
+                       trim(inFile)
+         end if
+         call finalize()
+         stop
+      else
+         nStrucs = inp%nStrucs
+      end if
+   end if
+ 
+   !--------- loop over all the structures from the input file ---------!
+ 
+   if (ppMaster .and. (inp%verbosity > 0)) then
+   !   call aeio_header('Energy evaluation')
+      write(ionum,*)
+   end if
+   
+ 
+   do istruc = 1, nStrucs
+      
+      iter = 0
+ 
+      ! only the master process reads the input structure:
+      if (ppMaster) then
+         if (len_trim(strucFile)>0) then
+            cooFile = strucFile
+         else
+            cooFile = inp%strucFile(istruc)
+         end if
+         call geo_init(cooFile, 'xsf')
+         ! convert atom type IDs to ANN potential IDs
+         allocate(atomType_orig(nAtoms))
+         atomType_orig = atomType
+         call aenet_convert_atom_types(&
+              atomTypeName, atomType_orig, atomType, stat)
+!         if (istruc == 1) then
+!            allocate(forCart_vec(3,nAtoms,nStrucs))
+!            allocate(Etot_vec(nStrucs))
+!            allocate(stress_vec(3,3,nStrucs))
+!         endif
+      end if
+      
+      call pp_bcast(nAtoms)
+      call pp_bcast(nTypes)
+      call pp_bcast(pbc)
+      call pp_bcast_latt(latticeVec)
+      call pp_bcast_latt(recLattVec)
+      
+ 
+      ! allocate memory for other parallel processes and transfer data
+      if (.not. ppMaster) then
+         allocate(cooLatt(3,nAtoms),   &
+                  atomType(nAtoms))
+      end if
+      if (inp%do_forces) then
+         allocate(forCart(3,nAtoms))
+         allocate(stress(3,3))
+      end if
+      if (inp%print_atomic_energies) then
+         allocate(atomicEnergy(nAtoms))
+      end if
+      call pp_bcast_coo(cooLatt, nAtoms)
+      call pp_bcast(atomType, nAtoms)
+     
+ 
+      ! write out basic structure info
+      if (ppMaster .and. (inp%verbosity > 0)) then
+         call print_fileinfo(istruc, cooFile, latticeVec, nAtoms, nTypes)
+      end if
+ 
+      ! evaluate atomic energy and forces
+      if (inp%do_forces .and. inp%print_atomic_energies) then
+         call get_energy(latticeVec, nAtoms, cooLatt, atomType, pbc, &
+                         Ecoh, Etot, forCart=forCart, atomicEnergy=atomicEnergy, stress=stress)
+      else if (inp%do_forces) then
+         call get_energy(latticeVec, nAtoms, cooLatt, atomType, pbc, &
+                         Ecoh, Etot, forCart=forCart, stress=stress)
+      else if (inp%print_atomic_energies) then
+         call get_energy(latticeVec, nAtoms, cooLatt, atomType, pbc, &
+                         Ecoh, Etot, atomicEnergy=atomicEnergy)
+      else
+         call get_energy(latticeVec, nAtoms, cooLatt, atomType, pbc, &
+                         Ecoh, Etot)
+      end if
+       
+ 
+      if (ppMaster) then
+         Etot_vec(istruc) = Etot
+         forCart_vec(:,:,istruc) = forCart(:,:)
+         stress_vec(:,:,istruc) = stress(:,:)
+         if (inp%do_forces .and. inp%print_atomic_energies) then
+            call print_coordinates(iter, latticeVec, nAtoms, nTypes, cooLatt, &
+                                   atomType_orig, atomTypeName, origin, &
+                                   forCart=forCart, atomicEnergy=atomicEnergy, stress=stress)
+         else if (inp%do_forces) then
+            call print_coordinates(iter, latticeVec, nAtoms, nTypes, cooLatt, &
+                                   atomType_orig, atomTypeName, origin, &
+                                   forCart=forCart, stress=stress)
+         else if (inp%print_atomic_energies) then
+            call print_coordinates(iter, latticeVec, nAtoms, nTypes, cooLatt, &
+                                   atomType_orig, atomTypeName, origin, &
+                                   atomicEnergy=atomicEnergy)
+         else
+            call print_coordinates(iter, latticeVec, nAtoms, nTypes, cooLatt, &
+                                   atomType_orig, atomTypeName, origin)
+         end if
+      end if
+ 
+      ! optimize coordinates, if requested:
+      if (inp%do_relax .and. inp%do_forces) then
+         E0 = Ecoh
+         if (ppMaster) then
+            call opt_init(inp%relax_method, 3*nAtoms, &
+                          ftol=inp%relax_E_conv, gtol=inp%relax_F_conv)
+            if (inp%verbosity > 0) then
+               write(*,*) "Geometry optimization:"
+               write(*,*)
+               write(*,*) '       ', '   energy change  ', '     rms force    '
+               write(*,*) '       ', '        (eV)      ', '     (eV/Ang)     '
+               write(*,*) repeat('-',60)
+            end if
+         end if
+         dmax = matmul(recLattVec, inp%relax_dmax)/(2.0d0*PI)
+         conv = .false.
+         relax : do while(iter < inp%relax_steps)
+            iter = iter + 1
+            if (ppMaster) then
+               call calc_rms_force(forCart, F_mav, F_max, imax, F_avg, F_rms)
+               if (inp%verbosity > 0) then
+                  if (iter>1) then
+                     write(*,'(1x,I5,2x,F16.8,2x,F16.8,2x,F16.8)') &
+                          iter, Ecoh-E0, F_rms, F_rms - F_rms_prev
+                  else
+                     write(*,'(1x,I5,2x,F16.8,2x,F16.8)') iter, Ecoh-E0, F_rms
+                  end if
+               end if
+               F_rms_prev = F_rms
+               call opt_optimize_coords(Ecoh, nAtoms, cooLatt, forCart, &
+                                        conv, dmax=(/0.1d0, 0.1d0, 0.1d0/))
+               if (.not. pbc) then
+                  call geo_update_bounds(cooLatt, latticeVec, recLattVec, origin)
+               end if
+            end if
+            call pp_bcast(conv)
+            if (conv) then
+               if (ppMaster .and. (inp%verbosity > 0)) then
+                  write(*,*) "   converged after ", &
+                             trim(io_adjustl(iter)), " iterations."
+               end if
+               exit relax
+            end if
+            call pp_bcast_coo(cooLatt, nAtoms)
+            call get_energy(latticeVec, nAtoms, cooLatt, atomType, pbc, &
+                            Ecoh, Etot, forCart=forCart)
+         end do relax
+         if (ppMaster) then
+            call opt_final()
+            write(*,*)
+            call print_coordinates(iter, latticeVec, nAtoms, nTypes, cooLatt, &
+                                   atomType_orig, atomTypeName, origin, forCart)
+         end if
+      end if
+ 
+      if (ppMaster) then
+         if (inp%do_forces) then
+            call print_energy(Ecoh, Etot, forCart)
+         else
+            call print_energy(Ecoh, Etot)
+         end if
+         call geo_final()
+         deallocate(atomType_orig)
+      else
+         deallocate(cooLatt, atomType)
+      end if
+      if (inp%do_forces) then
+         deallocate(forCart)
+         deallocate(stress)
+      end if
+      if (inp%print_atomic_energies) then
+         deallocate(atomicEnergy)
+      end if
+ 
+      if (ppMaster .and. istruc < nStrucs) then
+         write(ionum,*) repeat('+', 70)
+         write(ionum,*)
+      end if
+ 
+   end do
+ 
+   !--------------------------- finalization ---------------------------!
+  
+   call finalize()
+ 
+ contains
+ 
+   subroutine initialize(inFile, strucFile, inp)
+ 
+     implicit none
+ 
+     character(len=*), intent(in) :: inFile
+     character(len=*), intent(out) :: strucFile
+     type(InputData),  intent(out) :: inp
+ 
+ 
+     logical :: fexists
+     integer :: nargs
+     integer :: stat
+     integer :: itype
+     call pp_init()      
+
+     
+     if (ppMaster) then
+         inquire(file=trim(inFile), exist=fexists)    
+         strucFile = ''
+      ! read general input file
+         inp = read_InpPredict(inFile)
+     end if
+
+
+     !call pp_bcast(inFile)
+     call pp_bcast(strucFile)
+     call pp_bcast_InputData(inp)
+ 
+     if (inp%verbosity > 0) call pp_print_info()
+ 
+     ! initialize aenet
+     call aenet_init(inp%typeName, stat)
+     if (stat /= 0) then
+        write(0,*) 'Error: aenet initialization failed'
+        call finalize()
+        stop
+     end if
+ 
+     ! load ANN potentials
+     do itype = 1, inp%nTypes
+        call aenet_load_potential(itype, inp%netFile(itype), stat)
+        if (stat /= 0) then
+        write(0,*) 'Error: could not load ANN potentials'
+           call finalize()
+           stop
+        end if
+     end do
+ 
+     if (ppMaster .and. (inp%verbosity > 0)) then
+        ! write header and copyright info
+        !call aeio_header("Atomic Energy Network Interpolation", char='=')
+        !call aeio_header(aeio_timestamp(), char=' ')
+        write(ionum,*)
+        !call aeio_print_copyright('2015-2018', 'Nongnuch Artrith and Alexander Urban')
+     end if
+ 
+   end subroutine initialize
+ 
+   !--------------------------------------------------------------------!
+ 
+   subroutine finalize()
+ 
+     implicit none
+ 
+     integer :: stat
+ 
+     if (allocated(atomType_orig)) deallocate(atomType_orig)
+ 
+     if (ppMaster .and. (inp%verbosity > 0)) then
+     !   call aeio_header(aeio_timestamp(), char=' ')
+     !   call aeio_header("Atomic Energy Network done.", char='=')
+     end if
+ 
+     call aenet_final(stat)
+     !call pp_final()
+
+     call del_InputData(inp)
+ 
+  end subroutine finalize
+ 
+   !--------------------------------------------------------------------!
+ 
+   subroutine print_usage()
+ 
+     implicit none
+ 
+     write(ionum,*)
+     write(ionum,*) "predict.x -- Predict/interpolate atomic energy."
+     write(ionum,'(1x,70("-"))')
+     write(ionum,*) 'Usage: predict.x <input-file> [<structure files>]'
+     write(ionum,*)
+     write(ionum,*) 'See the documentation or the source code for a description of the'
+     write(ionum,*) 'input file format.  Structure files can either be listed in the'
+     write(ionum,*) 'input file, or specified on the command line.'
+     write(ionum,*)
+ 
+   end subroutine print_usage
+ 
+   !--------------------------------------------------------------------!
+   !                           general output                           !
+   !--------------------------------------------------------------------!
+ 
+   subroutine print_fileinfo(istruc, file, latticeVec, nAtoms, nTypes)
+ 
+     implicit none
+ 
+     integer,                                         intent(in) :: istruc
+     character(len=*),                                intent(in) :: file
+     double precision, dimension(3,3),                intent(in) :: latticeVec
+     integer,                                         intent(in) :: nAtoms
+     integer,                                         intent(in) :: nTypes
+ 
+     write(ionum,*) 'Structure number  : ', trim(io_adjustl(istruc))
+     write(ionum,*) 'File name         : ', trim(adjustl(file))
+     write(ionum,*) 'Number of atoms   : ', trim(io_adjustl(nAtoms))
+     write(ionum,*) 'Number of species : ', trim(io_adjustl(nTypes))
+     write(ionum,*)
+ 
+     write(ionum,*) 'Lattice vectors (Angstrom):'
+     write(ionum,*)
+     write(ionum,'(3x,"a = ( ",3(2x,F15.8)," )")') latticeVec(1:3,1)
+     write(ionum,'(3x,"b = ( ",3(2x,F15.8)," )")') latticeVec(1:3,2)
+     write(ionum,'(3x,"c = ( ",3(2x,F15.8)," )")') latticeVec(1:3,3)
+     write(ionum,*)
+ 
+   end subroutine print_fileinfo
+ 
+   !--------------------------------------------------------------------!
+ 
+   subroutine print_coordinates(iter, latticeVec, nAtoms, nTypes, cooLatt, &
+                                atomType, atomTypeName, origin, forCart, &
+                                atomicEnergy, stress)
+ 
+     implicit none
+ 
+     integer,                                         intent(in) :: iter
+     double precision, dimension(3,3),                intent(in) :: latticeVec
+     integer,                                         intent(in) :: nAtoms
+     integer,                                         intent(in) :: nTypes
+     double precision, dimension(3,nAtoms),           intent(in) :: cooLatt
+     integer,          dimension(nAtoms),             intent(in) :: atomType
+     character(len=*), dimension(nTypes),             intent(in) :: atomTypeName
+     double precision, dimension(3),                  intent(in) :: origin
+     double precision, dimension(3,nAtoms), optional, intent(in) :: forCart
+     double precision, dimension(nAtoms),   optional, intent(in) :: atomicEnergy
+     double precision, dimension(3,3), optional, intent(in)      :: stress
+ 
+     character(len=80)              :: header
+     integer                        :: iat
+     character(len=2)               :: symbol
+     double precision, dimension(3) :: cooCart
+ 
+     header = 'Cartesian atomic coordinates'
+     if (iter == 0) then
+        header = trim(header) // ' (input)'
+     else
+        header = trim(header) // ' (optimized)'
+     end if
+     if (present(forCart)) then
+        header = trim(header) // ' and corresponding atomic forces'
+     end if
+     header = trim(header) // ':'
+ 
+     write(ionum,*) trim(header)
+     write(ionum,*)
+     write(ionum,'(1x,2x,3(2x,A12))', advance='no') &
+          '     x      ', '     y      ', '     z      '
+     if (present(forCart)) then
+        write(ionum,'(3(2x,A12))', advance='no') &
+             '     Fx     ', '    Fy      ', '    Fz      '
+     end if
+     if (present(atomicEnergy)) then
+        write(ionum,'(2x,A12)', advance='no') '   E_atom   '
+     end if
+     write(ionum,*)
+     write(ionum,'(1x,2x,3(2x,A12))', advance='no') &
+          '    (Ang)   ', '    (Ang)   ', '    (Ang)   '
+     if (present(forCart)) then
+        write(ionum,'(3(2x,A12))', advance='no') &
+             '  (eV/Ang)  ', '  (eV/Ang)  ', '  (eV/Ang)  '
+     end if
+     if (present(atomicEnergy)) then
+        write(ionum,'(2x,A12)', advance='no') '    (eV)    '
+     end if
+     write(ionum,*)
+     write(ionum,'(1x,44("-"))', advance='no')
+     if (present(forCart)) write(ionum,'(42("-"))', advance='no')
+     if (present(atomicEnergy)) write(ionum,'(14("-"))', advance='no')
+     write(ionum,*)
+     do iat = 1, nAtoms
+        symbol = atomTypeName(atomType(iat))
+        cooCart(1:3) = matmul(latticeVec, cooLatt(1:3,iat)) + origin
+        write(ionum,'(1x,A2,3(2x,F12.6))', advance='no') symbol, cooCart(1:3)
+        if (present(forCart)) then
+           write(ionum,'(3(2x,F12.6))', advance='no') forCart(1:3,iat)
+        end if
+        if (present(atomicEnergy)) then
+           write(ionum,'(2x,F12.6)', advance='no') atomicEnergy(iat)
+        end if
+        write(ionum,*)
+     end do
+     write(ionum,*)
+ 
+     if (present(stress)) then
+        write(ionum,*) 'Stress tensor kbar         :'
+        do iat = 1, 3
+           write(ionum,'(3(2x,F12.6))') stress(1:3,iat)
+        end do
+     end if
+     
+ 
+   end subroutine print_coordinates
+ 
+   !--------------------------------------------------------------------!
+ 
+   subroutine print_energy(Ecoh, Etot, forCart)
+ 
+     implicit none
+ 
+     double precision,                           intent(in) :: Ecoh, Etot
+     double precision, dimension(:,:), optional, intent(in) :: forCart
+ 
+     double precision, dimension(3) :: F_mav, F_max, F_avg
+     double precision               :: F_rms
+     integer                        :: imax
+ 
+     write(ionum,'(1x,"Cohesive energy            :",2x,F20.8," eV")') Ecoh
+     write(ionum,'(1x,"Total energy               :",2x,F20.8," eV")') Etot
+     if (present(forCart)) then
+        call calc_rms_force(forCart, F_mav, F_max, imax, F_avg, F_rms)
+        write(ionum,'(1x,"Mean force (must be zero)  :",3(2x,F12.6))') F_avg(1:3)
+        write(ionum,'(1x,"Mean absolute force        :",3(2x,F12.6))') F_mav(1:3)
+        write(ionum,'(1x,"Maximum force              :",3(2x,F12.6))') F_max(1:3)
+        write(ionum,'(1x,"RMS force                  :",2x,F12.6)')    F_rms
+        write(ionum,*) 'The maximum force is acting on atom ', &
+             trim(io_adjustl(imax)), '.'
+        write(ionum,*) 'All forces are given in eV/Angstrom.'
+     end if
+     write(ionum,*)
+ 
+   end subroutine print_energy
+ 
+   !--------------------------------------------------------------------!
+   !                 calculate atomic energy and forces                 !
+   !--------------------------------------------------------------------!
+ 
+   subroutine get_energy(latticeVec, nAtoms, cooLatt, atomType, &
+                         pbc, Ecoh, Etot, forCart, atomicEnergy, stress)
+ 
+     implicit none
+ 
+     double precision, dimension(3,3),                intent(in)  :: latticeVec
+     integer,                                         intent(in)  :: nAtoms
+     double precision, dimension(3,nAtoms),           intent(in)  :: cooLatt
+     integer,          dimension(nAtoms),             intent(in)  :: atomType
+     logical,                                         intent(in)  :: pbc
+     double precision,                                intent(out) :: Ecoh
+     double precision,                                intent(out) :: Etot
+     double precision, dimension(3,nAtoms), optional, intent(out) :: forCart
+     double precision, dimension(nAtoms),   optional, intent(out) :: atomicEnergy
+     double precision, dimension(3,3), optional, intent(out) :: stress
+     double precision, dimension(3) :: tmp_vec
+     double precision :: vol
+ 
+#ifdef CHECK_FORCES
+     double precision, dimension(3,nAtoms) :: forCart_num
+     double precision                              :: E_i1, E_i2
+     double precision :: d
+     double precision, dimension(3,3) :: dd
+     integer :: i, j
+#endif
+ 
+     logical                                       :: do_F, do_E_atom, do_S
+ 
+     integer                                       :: nnb
+     integer,          dimension(aenet_nnb_max)    :: nblist
+     double precision, dimension(3,aenet_nnb_max)  :: nbcoo
+     double precision, dimension(aenet_nnb_max)    :: nbdist
+     integer,          dimension(aenet_nnb_max)    :: nbtype
+ 
+     integer                                       :: type_i
+     double precision, dimension(3)                :: coo_i
+     double precision                              :: E_i
+ 
+     integer                                       :: iatom, stat,x1,x2
+ 
+     do_F = present(forCart)
+     do_E_atom = present(atomicEnergy)
+     do_S = present(stress)
+     if (do_F) forCart(1:3,1:nAtoms) = 0.0d0
+     if (do_E_atom) atomicEnergy(1:nAtoms) = 0.0d0
+     if (do_S) stress(1:3,1:3) = 0.0d0
+
+      
+ 
+     call lcl_init(aenet_Rc_min, aenet_Rc_max, latticeVec, nAtoms, &
+                   atomType, cooLatt, pbc)
+ 
+#ifdef CHECK_FORCES
+     d = 0.01d0
+     dd(:,1) = [d, 0.0d0, 0.0d0]
+     dd(:,2) = [0.0d0, d, 0.0d0]
+     dd(:,3) = [0.0d0, 0.0d0, d]
+     forCart_num = 0.0d0
+#endif
+ 
+     Ecoh = 0.0d0
+     Etot = 0.0d0
+     atoms : do iatom = 1, nAtoms
+        ! write(*,*) iatom,"get energy before",ppRank
+ 
+        ! distribute atoms over processes:
+        if (mod(iatom-1,ppSize) /= ppRank) cycle
+ 
+        type_i = atomType(iatom)
+        coo_i(1:3) = matmul(latticeVec, cooLatt(1:3,iatom))
+ 
+        ! get all atoms of species type_i within the cut-off:
+        nnb = aenet_nnb_max
+        call lcl_nbdist_cart(iatom, nnb, nbcoo, nbdist, aenet_Rc_max, &
+                             nblist=nblist, nbtype=nbtype)
+ 
+        if (do_F) then
+           call aenet_atomic_energy_and_forces( &
+                coo_i, type_i, iatom, nnb, nbcoo, nbtype, nblist, &
+                nAtoms, E_i, forCart, stress, stat)
+#ifdef CHECK_FORCES
+           do i = 1, 3
+              coo_i = coo_i - dd(:,i)
+              call aenet_atomic_energy(coo_i, type_i, nnb, nbcoo, nbtype, &
+                                    E_i1, stat)
+              coo_i = coo_i + 2.0d0*dd(:,i)
+              call aenet_atomic_energy(coo_i, type_i, nnb, nbcoo, nbtype, &
+                                    E_i2, stat)
+              coo_i = coo_i - dd(:,i)
+              forCart_num(i,iatom) = forCart_num(i,iatom) - (E_i2 - E_i1)/(2.0d0*d)
+           end do
+           do j = 1, nnb
+              do i = 1, 3
+                 nbcoo(:,j) = nbcoo(:,j) - dd(:,i)
+                 call aenet_atomic_energy(coo_i, type_i, nnb, nbcoo, nbtype, &
+                                          E_i1, stat)
+                 nbcoo(:,j) = nbcoo(:,j) + 2.0d0*dd(:,i)
+                 call aenet_atomic_energy(coo_i, type_i, nnb, nbcoo, nbtype, &
+                                          E_i2, stat)
+                 nbcoo(:,j) = nbcoo(:,j) - dd(:,i)
+                 forCart_num(i,nblist(j)) = forCart_num(i,nblist(j)) - (E_i2 - E_i1)/(2.0d0*d)
+              end do
+           end do
+#endif
+        else
+           call aenet_atomic_energy(coo_i, type_i, nnb, nbcoo, nbtype, &
+                                    E_i, stat)
+        end if
+      ! write(*,*) iatom,"get energy before",ppRank
+ 
+        Etot = Etot + E_i
+        Ecoh = Ecoh + E_i - aenet_free_atom_energy(type_i)
+        if (do_E_atom) atomicEnergy(iatom) = E_i
+ 
+     end do atoms
+ 
+     if (do_S) then
+ 
+     end if
+ 
+#ifdef CHECK_FORCES
+     open(99, file='CHECK_FORCES.dat', status='replace', action='write')
+     do iatom = 1, nAtoms
+        write(99,'(9(1x,ES15.8))') &
+             forCart(1:3,iatom), forCart_num(1:3,iatom), &
+             forCart(1:3,iatom) - forCart_num(1:3,iatom)
+     end do
+     close(99)
+#endif
+ 
+     call lcl_final()
+ 
+     call pp_sum(Ecoh)
+     call pp_sum(Etot)
+     ! gather results from all processes
+     if (do_F) then
+        if (ppSize>1) then
+           do iatom = 1, nAtoms
+              call pp_sum(forCart(1:3,iatom), 3)
+           end do
+        end if
+     end if
+     !stress[kbar]
+     if (do_S) then
+        if (ppSize>1) then
+           do x1 = 1,3
+              call pp_sum(stress(1:3,x1), 3)
+           end do
+        end if
+        tmp_vec(1)=latticeVec(2,1)*latticeVec(3,2)-latticeVec(3,1)*latticeVec(2,2)
+        tmp_vec(2)=latticeVec(3,1)*latticeVec(1,2)-latticeVec(1,1)*latticeVec(3,2)
+        tmp_vec(3)=latticeVec(1,1)*latticeVec(2,2)-latticeVec(2,1)*latticeVec(1,2)
+        vol=0.0d0
+        do x1 = 1, 3
+           vol = vol + latticeVec(x1,3)* tmp_vec(x1)
+        end do
+        do x1 = 1,3
+           do x2 = x1,3
+              stress(x2,x1)=stress(x2,x1)/vol*1.d3*1.6021774232052327
+              stress(x1,x2)=stress(x2,x1)
+           end do
+        end do
+     end if
+ 
+     if (do_E_atom) call pp_sum(atomicEnergy(1:nAtoms), nAtoms)
+ 
+   end subroutine get_energy
+ 
+   !--------------------------------------------------------------------!
+   !                       analyze atomic forces                        !
+   !--------------------------------------------------------------------!
+ 
+   subroutine calc_rms_force(forCart, F_mav, F_max, imax, F_avg, F_rms)
+ 
+     implicit none
+ 
+     double precision, dimension(:,:), optional, intent(in)  :: forCart
+     double precision, dimension(3),             intent(out) :: F_mav
+     double precision, dimension(3),             intent(out) :: F_max
+     integer,                                    intent(out) :: imax
+     double precision, dimension(3),             intent(out) :: F_avg
+     double precision,                           intent(out) :: F_rms
+ 
+     integer                        :: nAtoms
+     double precision               :: F_abs2, F_abs2_max
+     integer                        :: iat
+ 
+     nAtoms = size(forCart(1,:))
+     F_rms       = 0.0d0
+     F_mav(1:3)  = 0.0d0
+     F_max(1:3)  = 0.0d0
+     F_avg(1:3)  = 0.0d0
+     F_abs2      = 0.0d0
+     F_abs2_max  = 0.0d0
+     do iat = 1, nAtoms
+        F_avg(1:3) = F_avg(1:3) + forCart(1:3,iat)
+        F_mav(1:3) = F_mav(1:3) + abs(forCart(1:3,iat))
+        F_abs2 = sum(forCart(1:3,iat)*forCart(1:3,iat))
+        F_rms  = F_rms + F_abs2
+        if (F_abs2 > F_abs2_max) then
+           F_abs2_max  = F_abs2
+           F_max(1:3) = forCart(1:3,iat)
+           imax       = iat
+        end if
+     end do
+     F_avg(1:3) = F_avg(1:3)/dble(nAtoms)
+     F_mav(1:3) = F_mav(1:3)/dble(nAtoms)
+     F_rms = sqrt(F_rms/dble(nAtoms))
+ 
+   end subroutine calc_rms_force
+ 
+end subroutine predict_sub
diff -Naru src/aenet_train.f90 src_modified/aenet_train.f90
--- src/aenet_train.f90	1970-01-01 09:00:00.000000000 +0900
+++ src_modified/aenet_train.f90	2025-04-08 13:27:27.571785759 +0900
@@ -0,0 +1,1499 @@
+!-----------------------------------------------------------------------
+!     train.x - train (fit) atomic energy neural network potential
+!-----------------------------------------------------------------------
+!+ This file is part of the AENET package.
+!+
+!+ Copyright (C) 2012-2018 Nongnuch Artrith and Alexander Urban
+!+
+!+ This Source Code Form is subject to the terms of the Mozilla Public
+!+ License, v. 2.0. If a copy of the MPL was not distributed with this
+!+ file, You can obtain one at http://mozilla.org/MPL/2.0/.
+!+
+!+ This program is distributed in the hope that it will be useful, but
+!+ WITHOUT ANY WARRANTY; without even the implied warranty of
+!+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+!+ Mozilla Public License, v. 2.0, for more details.
+!-----------------------------------------------------------------------
+! 2011-10-19 Alexander Urban (AU), Nongnuch Artrith (NA)
+!-----------------------------------------------------------------------
+
+subroutine train_sub(inFile,ionum,dirname)
+
+  use aeio,        only: aeio_readline,          &
+                         aeio_header,            &
+                         aeio_timestamp,         &
+                         aeio_print_copyright,   &
+                         PATHLEN, TYPELEN
+
+  use feedforward, only: Network,                &
+                         new_Network,            &
+                         del_Network,            &
+                         save_Network,           &
+                         load_Network,           &
+                         ff_change_activation,   &
+                         ff_random_init_weights, &
+                         ff_update_weights,      &
+                         ff_get_nweights,        &
+                         ff_print_info,          &
+                         ff_eval,                &
+                         ff_deriv,               &
+                         ff_wderiv
+
+  use geometry,    only: geo_itype_of_name
+
+  use input,       only: InputData,              &
+                         read_InpTrain,          &
+                         del_InputData,          &
+                         inp_read_networks
+
+  use io,          only: io_adjustl,             &
+                         io_center,              &
+                         io_lower,               &
+                         io_readval,             &
+                         io_readnext,            &
+                         io_unit
+
+  use optimize,    only: opt_init_training,      &
+                         opt_final,              &
+                         opt_before_batch,       &
+                         opt_after_sample,       &
+                         opt_after_batch,        &
+                         opt_print_info,         &
+                         opt_schedule_epoch,     &
+                         opt_schedule,           &
+                         opt_samplesize_local,   &
+                         opt_batchsize_local,    &
+                         opt_nbatch
+
+  use parallel,    only: pp_init,                &
+                         pp_final,               &
+                         pp_print_info,          &
+                         pp_bcast,               &
+                         pp_recv,                &
+                         pp_send,                &
+                         pp_sum,                 &
+                         pp_sum2d,               &
+                         pp_bcast_Network,       &
+                         pp_bcast_InputData,     &
+                         pp_bcast_TrnSet_info,   &
+                         pp_sum_weights,         &
+                         ppMaster,               &
+                         ppRank,                 &
+                         ppSize
+
+  use random,      only: random_init,            &
+                         random_reinit,          &
+                         random_final,           &
+                         random_save_state,      &
+                         random_load_state
+
+  use sfsetup,     only: Setup,                  &
+                         load_Setup,             &
+                         save_Setup,             &
+                         skip_Setup,             &
+                         del_Setup
+
+  use timing,      only: tng_init,               &
+                         tng_final,              &
+                         tng_timing,             &
+                         tng_timing2,            &
+                         tng_timing3,            &
+                         tng_dump
+
+  use trainset,    only: TrnSet,                  &
+                         new_TrnSet,              &
+                         open_TrnSet,             &
+                         rewind_TrnSet,           &
+                         close_TrnSet,            &
+                         save_TrnSet_info,        &
+                         ts_count_atoms,          &
+                         ts_load_Setups,          &
+                         ts_print_info,           &
+                         ts_read_atom_info,       &
+                         ts_read_sf_info,         &
+                         ts_read_sf_values,       &
+                         ts_read_structure_info,  &
+                         ts_write_atom_info,      &
+                         ts_write_sf_info,        &
+                         ts_write_structure_info, &
+                         ts_skip_atoms
+
+  implicit none
+
+  !--------------------------------------------------------------------!
+  ! RNG_STATE_FILE    filename to save state of the random number      !
+  !                   generator, needed for restarting the testing set !
+  ! STOP_FILE         name of the file that causes training to stop    !
+  !--------------------------------------------------------------------!
+
+  character(len=*), parameter :: RNG_STATE_FILE = 'train.rngstate'
+  character(len=*), parameter :: STOP_FILE = 'STOP'
+
+  !--------------------------------------------------------------------!
+  ! A '*' in front of the variable name means that it is a broadcasted !
+  ! variable and has the same value on each process.  A '+' means that !
+  ! an array is allocated on all parallel processes, but does not      !
+  ! necessarily have the same contents.                                !
+  !                                                                    !
+  !----------------------------- general ------------------------------!
+  ! inFile          name of the input file                             !
+  !*inp             input data object                                  !
+  !                                                                    !
+  !--------------------------- training set ---------------------------!
+  ! restarted       .true. if the testing set is restarted             !
+  ! ts              training set; instance of TrnSet                   !
+  ! E_av, E_min, E_max  average, minimum and maximum cohesive energy   !
+  !                 per atom in the training set structures            !
+  !*Escale          the cohesive energy will be normalized to the      !
+  !                 interval [-1:1] before the training                !
+  !                 E_new = Escale*E                                   !
+  !*nTrain          number of structures actually used for training    !
+  !*nTest           size of the testing set = ts%nStrucs - nTrain      !
+  !*nAtomsTrain     total number of atoms in the training set          !
+  !*nAtomsTest      total number of atoms in the testing set           !
+  !*isTest(i)       .true., if the i-th structure belongs to the       !
+  !                 testing set                                        !
+  !+trnEnergies(i)  reference energy of the i-th structure             !
+  !+trnErrors(i)    current error of the i-th structure                !
+  !                                                                    !
+  !------------------------- training method --------------------------!
+  !*iepoch          current epoch/training iteration                   !
+  !*conv            .true., if training has converged                  !
+  !*batchsize       size of the sliding window batch, if any           !
+  !*nextbatch       .true., if the window shall be updated             !
+  ! ibatch          process local batch counter                        !
+  ! batchiter       iterations for the same batch so far               !
+  !                                                                    !
+  !------------------- structural fingerprint basis -------------------!
+  ! stp(itype)      basis function set-up for atom type itype          !
+  !*nsf_max         max. number of basis functions over all set-ups    !
+  !                                                                    !
+  !----------------------------- networks -----------------------------!
+  !*net(itype)      neural network for central atom type itype         !
+  !*nw_max          max. number of network weights over all networks   !
+  !*nw_tot          total number (sum) of network weights              !
+  ! iw, nw          generic weight counters                            !
+  !+Dw(k,l)         = sum_i Dw_i(k) ; for atom type l                  !
+  !+ann_values(i)   value of the i-th ANN node                         !
+  !+ann_derivs(i)   derivative of the i-th ANN node value              !
+  !+ann_jacobian(i) derivative of the ANN output wrt. the i-th weight  !
+  !                                                                    !
+  !----------------------------- parallel -----------------------------!
+  !+ts_trn, ts_tst  process local train and test data sets             !
+  !*stopnow         if .true., stop immediately                        !
+  !--------------------------------------------------------------------!
+
+!  character(len=100)                               :: inFile
+  character(len=*),intent(in)                    :: inFile
+  integer,intent(in)                             ::ionum
+  character(len=*),intent(in)           ::dirname
+
+  type(InputData)                                  :: inp
+
+  logical                                          :: restarted
+  type(TrnSet)                                     :: ts
+  integer                                          :: nTrain
+  integer                                          :: nTest
+  integer                                          :: nAtomsTrain
+  integer                                          :: nAtomsTest
+  logical,           dimension(:),     allocatable :: isTest
+
+  integer                                          :: iepoch
+  logical                                          :: conv
+  integer                                          :: batchsize
+  logical                                          :: do_nextbatch
+  integer                                          :: ibatch
+  double precision, dimension(:),      allocatable :: trnEnergies
+  double precision, dimension(:),      allocatable :: trnErrors
+
+  logical                                          :: do_deriv
+
+  type(Setup),       dimension(:),     allocatable :: stp
+  integer                                          :: nsf_max
+
+  type(Network),     dimension(:),     allocatable :: net
+  integer                                          :: nnodes_max
+  integer                                          :: nw_max
+  integer                                          :: nw_tot
+  double precision,  dimension(:,:),   allocatable :: Dw
+  double precision,  dimension(:),     allocatable :: ann_values
+  double precision,  dimension(:),     allocatable :: ann_derivs
+  double precision,  dimension(:),     allocatable :: ann_jacobian
+
+  type(TrnSet)                                     :: ts_trn, ts_tst
+  integer                                          :: itrn
+  logical                                          :: stopnow
+
+  double precision                                 :: dE
+  double precision                                 :: MAE_trn, MAE_tst
+  double precision                                 :: SSE_trn, SSE_tst
+  double precision                                 :: RMSE_trn, RMSE_tst
+
+  integer                                          :: u_dbg, u_tng
+
+  integer                                          :: irec, isample
+
+  ! timing registers
+  integer, parameter :: R_TRN = 1, R_TST = 2
+
+  external :: DSYR2K ! BLAS
+
+  !-------------------------- initialization --------------------------!
+
+  call initialize(inFile)
+
+  stopnow = .false.
+  if (ppMaster) then
+     inp = read_InpTrain(inFile)
+     if (.not. inp%init) then
+        stopnow = .true.
+     else
+        ! load training set
+        ts = open_TrnSet(inp%trn_file, maxenergy=inp%trn_maxenergy)
+        ! load basis function set ups
+        allocate(stp(ts%nTypes))
+        call ts_load_Setups(ts,stp)
+        ! synchronize file types and read NN file names
+        inp%nTypes = ts%nTypes
+        allocate(inp%typeName(inp%nTypes))
+        inp%typeName(:) = ts%typeName(:)
+        call inp_read_networks(inp, file=trim(inp%file), readarch=.true.)
+        allocate(net(ts%nTypes))
+        ! set up NNs
+        call init_networks(inp, stp, net)
+        ! max basis functions and weights
+        nsf_max = max_num_sf()
+        call get_num_nodes(ts, nnodes_max)
+        call get_num_weights(ts, nw_max, nw_tot)
+     end if
+  end if
+  call pp_bcast(stopnow)
+  if (stopnow) then
+     call finalize()
+     stop
+  end if
+  call pp_bcast_InputData(inp)
+  call pp_bcast_TrnSet_info(ts)
+  call broadcast_networks()
+  call pp_bcast(nsf_max)
+  call pp_bcast(nnodes_max)
+  call pp_bcast(nw_max)
+  call pp_bcast(nw_tot)
+
+  ! allocate memory for ANN values, derivatives, and Jacobian
+  allocate(ann_values(nnodes_max), &
+           ann_derivs(nnodes_max), &
+           ann_jacobian(nw_max))
+
+  if (inp%do_timing .and. ppMaster) then
+     u_tng = io_unit()
+     call tng_init(unit=u_tng, file='train.time', registers=2)
+     write(ionum,*) 'Timing info will be written to: train.time'
+     write(ionum,*)
+  end if
+  if (inp%do_debug) then
+     u_dbg = io_unit()
+     open(u_dbg, file='train.debug'//trim(io_adjustl(ppRank)), &
+          status='replace', action='write')
+  end if
+
+  if (ppMaster) call save_all_networks(verbose=.true.,directoryname=dirname)
+
+  !------------- set-up of the training and testing sets --------------!
+
+  allocate(isTest(ts%nStrucs))
+  if (ppMaster) then
+     ! devide structures into test and train set:
+     call decide_testing_set(ts%nStrucs, inp%trn_testset, nTrain, nTest, &
+                             isTest, restarted)
+     ! count total number of atoms in train and test structures:
+     call rewind_TrnSet(ts)
+     call ts_count_atoms(ts, isTest, nAtomsTrain, nAtomsTest)
+     call ts_print_info(ts)
+     call print_training_info()
+  end if
+  call pp_bcast(isTest, ts%nStrucs)
+  call pp_bcast(nAtomsTrain)
+  call pp_bcast(nTrain)
+  call pp_bcast(nAtomsTest)
+  call pp_bcast(nTest)
+
+  if (inp%do_timing .and. ppMaster) &
+       call tng_timing('Training set initialized.')
+
+  ! distribute the training and testing structures:
+  call distribute_trnfile(isTest, nsf_max, ts, ts_trn, ts_tst)
+
+  ! allocate arrays for process local energies and errors
+  allocate(trnEnergies(ts_trn%nStrucs), trnErrors(ts_trn%nStrucs))
+  ! the reference energies don't change. Store once and for all.
+  call store_training_set_energies(ts_trn, trnEnergies)
+
+  if (inp%do_timing .and. ppMaster) &
+       call tng_timing('Structures distributed over processes')
+
+  !------------------ training method initialization ------------------!
+
+  call opt_init_training(inp%trn_method, inp%trn_param, inp%trn_sampling, &
+                         nw_tot, nw_max, nTrain, ts_trn%nStrucs, &
+                         ts_trn%nTypes)
+
+  allocate(Dw(nw_max,ts%nTypes))
+
+  if (inp%do_timing .and. ppMaster) then
+     call tng_timing('Optimization method (' // trim(inp%trn_method) &
+                     // ') initialized.')
+  end if
+
+  !--------------- initial status (before any training) ---------------!
+
+  if (ppMaster) &
+     call print_training_header(inp%trn_steps, inp%trn_methodName)
+
+  call eval_entire_trainset(ts_trn, nTrain, nsf_max, nw_max, net, &
+                            MAE_trn, SSE_trn, errors=trnErrors)
+  call eval_entire_trainset(ts_tst, nTest, nsf_max, nw_max, net, &
+                            MAE_tst, SSE_tst)
+
+  if (ppMaster) call print_energies(0, &
+       MAE_trn/ts_trn%scale, sqrt(2.0d0*SSE_trn/dble(nTrain))/ts_trn%scale, &
+       MAE_tst/ts_trn%scale, sqrt(2.0d0*SSE_tst/dble(nTest))/ts_tst%scale)
+
+  if (inp%do_timing .and. ppMaster) &
+       call tng_timing('Initial energies evaluated (before training)')
+
+  !----------------------------- training -----------------------------!
+
+  conv = .false.
+  epochs : do iepoch = 1, inp%trn_steps
+
+     if (conv) then
+        if (ppMaster) then
+           write(ionum,*) 'The optimization has converged. Training stopped.'
+           write(ionum,*)
+        end if
+        exit epochs
+     end if
+
+     call opt_schedule_epoch(ts_trn%nStrucs, trnEnergies, trnErrors)
+
+     if (inp%do_timing .and. ppMaster) &
+          call tng_timing('Starting epoch ' // io_adjustl(iepoch))
+
+     ibatch       = 1
+     do_nextbatch = .true.
+     do_deriv     = .true.
+
+     batches : do while (ibatch <= opt_nbatch)
+
+        call opt_before_batch()
+
+        !--------------!
+        ! training set !
+        !--------------!
+
+        irec = (ibatch - 1)*opt_batchsize_local
+        training : do itrn = 1, opt_batchsize_local
+
+           ! go to next record in training set file
+           ! after the last record, start from beginning
+           irec = mod(irec, opt_samplesize_local) + 1
+           isample = opt_schedule(irec)
+
+           if (isample /= (ts_trn%iStruc + 1)) then
+              call rewind_TrnSet(ts_trn, rec=isample)
+           end if
+
+           if (do_deriv) then
+              ! get error function and gradient
+              call eval_next_structure(ts_trn, nsf_max, nw_max, net, dE, Dw=Dw)
+           else
+              ! only compute error
+              call eval_next_structure(ts_trn, nsf_max, nw_max, net, dE)
+           end if
+
+           call opt_after_sample(net, ts, dE, Dw)
+
+        end do training
+
+        call opt_after_batch(net, ts, do_deriv, do_nextbatch, conv)
+
+        if (inp%do_timing .and. ppMaster) then
+           call tng_timing2('Done with training iteration.')
+           call tng_timing3(register=R_TRN)
+        end if
+
+        if (do_nextbatch) ibatch = ibatch + 1
+
+     end do batches
+
+     !-----------------------------!
+     ! current training set errors !
+     !-----------------------------!
+
+     ! FIXME: evaluation here not needed when using batch training
+     call eval_entire_trainset(ts_trn, nTrain, nsf_max, nw_max, net, &
+                               MAE_trn, SSE_trn, errors=trnErrors)
+
+     if (inp%do_timing .and. ppMaster) then
+        call tng_timing2('Done with training set energies.')
+        call tng_timing3(register=R_TRN)
+     end if
+
+     !-------------------------!
+     ! current test set errors !
+     !-------------------------!
+
+     call eval_entire_trainset(ts_tst, nTest, nsf_max, nw_max, net, &
+                               MAE_tst, SSE_tst)
+
+     if (inp%do_timing .and. ppMaster) then
+        call tng_timing2('Done with testing set energies.')
+        call tng_timing3(register=R_TST)
+     end if
+
+     if (ppMaster) then
+        RMSE_trn = sqrt(2.0d0*SSE_trn/dble(nTrain))
+        RMSE_tst = sqrt(2.0d0*SSE_tst/dble(nTest))
+        call print_energies(iepoch, &
+             MAE_trn/ts_trn%scale, RMSE_trn/ts_trn%scale, &
+             MAE_tst/ts_trn%scale, RMSE_tst/ts_tst%scale  )
+        call save_all_networks(iter=iepoch,directoryname=dirname)
+     end if
+
+     ! synchronize networks (to avoid numerical problems)
+     if (ppSize>1) call broadcast_networks()
+
+     if (inp%do_timing .and. ppMaster) &
+          call tng_timing2('Done with epoch '//trim(io_adjustl(iepoch)))
+
+     if (check_stopfile()) exit epochs
+
+  end do epochs
+
+  if (ppMaster) then
+     write(ionum,*)
+     write(ionum,*) 'Training finished.'
+     write(ionum,*)
+  end if
+
+  if (inp%do_timing .and. ppMaster) then
+     call tng_timing('Training finished.')
+     call tng_dump(R_TRN, 'Total time spent for training set.')
+     call tng_dump(R_TST, 'Total time spent for testing set.')
+  end if
+
+  !---------------- save final energies, if requested -----------------!
+
+  if (inp%do_save_energies) then
+     call save_all_energies(&
+          ts_trn, ts_tst, nTrain, nTest, nsf_max, nw_max, net)
+     if (inp%do_timing .and. ppMaster) &
+          call tng_timing('Stored energies of all structures.')
+  end if
+
+  !--------------------------- finalization ---------------------------!
+
+  call finalize()
+
+
+contains !=============================================================!
+
+
+  subroutine initialize(inFile)
+
+    implicit none
+
+    character(len=*), intent(in) :: inFile
+
+    logical :: fexists
+    integer :: nargs
+    logical :: stopnow
+
+    call pp_init()
+
+    stopnow = .false.
+    if (ppMaster) then
+       call aeio_header("Training process started.", char='=')
+       call aeio_header(aeio_timestamp(), char=' ')
+       write(ionum,*)
+
+       call aeio_print_copyright('2015-2018', 'Nongnuch Artrith and Alexander Urban')
+
+!       nargs = command_argument_count()
+!       if (nargs < 1) then
+!          write(0,*) "Error: No input file provided."
+!          call print_usage()
+!          stopnow = .true.
+!       end if
+
+!       call get_command_argument(1, value=inFile)
+!       inquire(file=trim(inFile), exist=fexists)
+!       if (.not. fexists) then
+!          write(0,*) "Error: File not found: ", trim(inFile)
+!          call print_usage()
+!          stopnow = .true.
+!       end if
+
+       call random_init()
+    end if
+
+    call pp_bcast(stopnow)
+    if (stopnow) then
+       call finalize()
+       stop
+    end if
+
+    call pp_print_info()
+
+  end subroutine initialize
+
+  !--------------------------------------------------------------------!
+
+  subroutine init_networks(inp, stp, net)
+
+    implicit none
+
+    type(InputData),                intent(in)    :: inp
+    type(Setup),      dimension(:), intent(in)    :: stp
+    type(Network),    dimension(:), intent(inout) :: net
+
+    integer           :: i, ipos, itype
+    integer           :: il, nl, nlmax
+    logical           :: fexists
+    character(len=20) :: nodes
+
+    integer,           dimension(:), allocatable :: arch
+    character(len=10), dimension(:), allocatable :: ftype
+
+    nlmax = 10
+    allocate(arch(nlmax), ftype(nlmax))
+
+    call aeio_header("Networks")
+    write(ionum,*)
+
+    do itype = 1, inp%nTypes
+       inquire(file=trim(inp%netFile(itype)), exist=fexists)
+
+       if (fexists) then
+          ! restart the network:
+          write(ionum,*) 'Restarting the ', trim(inp%typeName(itype)), &
+                     ' network from file : ', trim(inp%netFile(itype))
+          net(itype) = load_Network(trim(inp%netFile(itype)))
+       else
+          ! set up a new network:
+          write(ionum,*) 'Creating a new ', trim(inp%typeName(itype)), ' network'
+          ipos = 1
+          call io_readnext(inp%netArch(itype), ipos, nl)
+          if (nl+2 > nlmax) then
+             ! reallocate arrays, if more memory is needed
+             nlmax = nl + 2
+             if (allocated(arch)) deallocate(arch, ftype)
+             allocate(arch(nlmax), ftype(2:nlmax))
+          end if
+          arch(1)     = stp(itype)%nsf
+          arch(nl+2)  = 1
+          ftype(nl+2) = 'linear'
+          do il = 1, nl
+             call io_readnext(inp%netArch(itype), ipos, nodes)
+             i = scan(nodes, ':')
+             read(nodes(1:i-1), *)          arch(il+1)
+             read(nodes(i+1:len(nodes)), *) ftype(il+1)
+          end do
+          net(itype) = new_Network(arch(1:nl+2))
+          do il = 2, nl+2
+             call ff_change_activation(net(itype), il, ftype(il))
+          end do
+          call ff_random_init_weights(net(itype))
+       end if ! restart
+
+       ! write out network information:
+       write(ionum,*)
+       call ff_print_info(net(itype))
+
+    end do ! itype
+
+  end subroutine init_networks
+
+  !--------------------------------------------------------------------!
+
+  subroutine finalize()
+
+    implicit none
+
+    integer :: itype
+
+    if (ppMaster) then
+       ! write current networks to files:
+       call save_all_networks(verbose=.true.,directoryname=dirname)
+    end if
+
+    ! deallocate memory needed for optimization:
+    call opt_final()
+
+    if (allocated(trnEnergies)) deallocate(trnEnergies, trnErrors)
+
+    if (allocated(ann_values)) deallocate(ann_values, ann_derivs, ann_jacobian)
+
+    if (allocated(stp)) then
+       do itype = 1, ts%nTypes
+          call del_Setup(stp(itype))
+       end do
+       deallocate(stp)
+    end if
+
+    if (allocated(net)) then
+       do itype = 1, ts%nTypes
+          call del_Network(net(itype))
+       end do
+       deallocate(net)
+    end if
+
+    ! close training sets
+    if (ts%init)     call close_TrnSet(ts)
+    if (ts_trn%init) call close_TrnSet(ts_trn, status='delete')
+    if (ts_tst%init) call close_TrnSet(ts_tst, status='delete')
+
+    if (allocated(isTest))  deallocate(isTest)
+    if (allocated(Dw))      deallocate(Dw)
+
+    if (ppMaster) then
+       call aeio_header(aeio_timestamp(), char=' ')
+       call aeio_header("Neural Network training done.", char='=')
+       call random_final()
+    end if
+
+    if (inp%do_debug) close(u_dbg)
+
+    if (inp%do_timing .and. ppMaster) call tng_final()
+
+    call pp_final()
+
+  end subroutine finalize
+
+  !--------------------------------------------------------------------!
+
+  function check_stopfile() result(fexists)
+
+    implicit none
+
+    logical :: fexists
+
+    if (ppMaster) then
+       inquire(file=STOP_FILE, exist=fexists)
+       if (fexists) write(ionum,*) "File `STOP' detected.  Training halted."
+    end if
+    call pp_bcast(fexists)
+
+  end function check_stopfile
+
+  !--------------------------------------------------------------------!
+
+  subroutine print_usage()
+
+    implicit none
+
+    write(ionum,*)
+    write(ionum,*) "train.x -- Train an atomic energy NN."
+    write(ionum,'(1x,70("-"))')
+    write(ionum,*) 'Usage: train.x <input-file>'
+    write(ionum,*)
+    write(ionum,*) 'See the documentation or the source code for a description of the '
+    write(ionum,*) 'input file format.'
+    write(ionum,*)
+
+  end subroutine print_usage
+
+  !--------------------------------------------------------------------!
+  !             target energies of all training structures             !
+  !--------------------------------------------------------------------!
+
+  subroutine store_training_set_energies(ts, energies)
+
+    implicit none
+
+    type(TrnSet),                   intent(inout) :: ts
+    double precision, dimension(:), intent(out)   :: energies
+
+    character(len=1024) :: filename
+    integer             :: nAtoms
+    integer             :: nTypes
+    double precision    :: E_coh
+    integer             :: i
+
+    call rewind_TrnSet(ts)
+    do i = 1, ts%nStrucs
+       call ts_read_structure_info(ts, filename, nAtoms, nTypes, E_coh)
+       energies(i) = E_coh
+       call ts_skip_atoms(ts, nAtoms)
+    end do
+    call rewind_TrnSet(ts)
+
+  end subroutine store_training_set_energies
+
+  !--------------------------------------------------------------------!
+  !                     actual network evaluation                      !
+  !--------------------------------------------------------------------!
+
+  !--------------------- evaluate whole data set ----------------------!
+
+  subroutine eval_entire_trainset(ts, N, nsf_max, nw_max, net, &
+                                  MAE, SSE, errors, save_energies)
+
+    implicit none
+
+    !------------------------------------------------------------------!
+    ! ts          training set instance to be read from                !
+    ! N           total number of structures for normalization         !
+    !             (not necessarily equal to ts%nStrucs)                !
+    ! nsf_max     max. number of basis functions                       !
+    ! nw_max      max. number of network weights                       !
+    ! net(i,j)    NN for atom types i and j                            !
+    ! MAE         mean absolute error                                  !
+    ! SSE         sum of squared errors                                !
+    !------------------------------------------------------------------!
+
+    type(TrnSet),                             intent(inout) :: ts
+    integer,                                  intent(in)    :: N
+    integer,                                  intent(in)    :: nsf_max
+    integer,                                  intent(in)    :: nw_max
+    type(Network),    dimension(:),           intent(inout) :: net
+    double precision,                         intent(out)   :: MAE
+    double precision,                         intent(out)   :: SSE
+    double precision, dimension(:), optional, intent(out)   :: errors
+    integer,                        optional, intent(in)    :: save_energies
+
+
+    double precision :: dE, error
+    integer :: i
+
+    MAE = 0.0d0
+    SSE = 0.0d0
+
+    call rewind_TrnSet(ts)
+    do i = 1, ts%nStrucs
+       if (present(save_energies)) then
+          call eval_next_structure(ts, nsf_max, nw_max, net, dE, &
+                                   save_energies=save_energies)
+       else
+          call eval_next_structure(ts, nsf_max, nw_max, net, dE)
+       end if
+       error = 0.5d0*dE*dE
+       if (present(errors)) errors(i) = error
+       MAE = MAE + abs(dE)/dble(N)
+       SSE = SSE + error
+    end do
+
+    if (ppSize > 1) then
+       call pp_sum(MAE)
+       call pp_sum(SSE)
+    end if
+
+  end subroutine eval_entire_trainset
+
+  !-------------------- evaluate single structure ---------------------!
+
+  subroutine eval_next_structure(ts, nsf_max, nw_max, net, dE, dF, Dw, &
+                                 save_energies)
+    implicit none
+
+    !------------------------------------------------------------------!
+    ! ts          training set instance to be read rom                 !
+    ! nsf_max     max. number of basis functions                       !
+    ! net(i,j)    NN for atom types i and j                            !
+    ! dE          energy difference per atom: dE=(E_coh-E_nn)/nAtoms   !
+    ! dF(i,j)     difference in the i-th force component of the j-th   !
+    !             atom: dF(i,j)=F_nn(i,j)-F(i,j)  [optional]           !
+    !             Note: force evaluation not yet implemented here !!   !
+    ! Dw          Jacobian with weight derivatives [optional]          !
+    !------------------------------------------------------------------!
+
+    type(TrnSet),                                 intent(inout) :: ts
+    integer,                                      intent(in)    :: nsf_max
+    integer,                                      intent(in)    :: nw_max
+    type(Network),    dimension(:),               intent(inout) :: net
+    double precision,                             intent(out)   :: dE
+    double precision, dimension(:,:),   optional, intent(out)   :: dF
+    double precision, dimension(:,:),   optional, intent(out)   :: Dw
+    integer,                            optional, intent(in)    :: save_energies
+
+    !------------------------------------------------------------------!
+    ! iatom, nAtoms  counter and total number for atoms in structure   !
+    ! itype, nTypes  counter and total number for species in structure !
+    ! itype          the atomic species of the current network         !
+    ! E_coh          cohesive (target) energy                          !
+    ! forCart(1:3)   Cartesian (target) force of current atom          !
+    ! cooCart(1:3)   Cartesian coordinates of current atom             !
+    ! nsf, nw        number of basis functions and weights             !
+    ! sfval(i)       value of the i-th basis function                  !
+    ! E_i            predicted atomic energy of the current atom       !
+    ! E_nn           total NN predicted energy = sum_i E_i             !
+    ! F_i(i)         derivative of E_i wrt. i-th basis function        !
+    ! Dw_i(i)        derivative of E_i wrt. i-th weight                !
+    !------------------------------------------------------------------!
+
+    integer                                :: iatom, nAtoms
+    integer                                :: nTypes
+    integer                                :: itype
+    character(len=1024)                    :: filename
+    double precision                       :: E_coh
+    double precision, dimension(3)         :: forCart, cooCart
+    integer                                :: nsf, nw
+    double precision, dimension(nsf_max)   :: sfval
+    double precision                       :: E_nn, E_i
+    double precision, dimension(nsf_max)   :: F_i
+    double precision, dimension(nw_max)    :: Dw_i
+    integer,          dimension(ts%nTypes) :: natoms_type
+
+    if (present(save_energies)) natoms_type(1:ts%nTypes) = 0
+
+    E_nn = 0.0d0
+    if (present(Dw)) Dw(:,:) = 0.0d0
+    call ts_read_structure_info(ts, filename, nAtoms, nTypes, E_coh)
+    do iatom = 1, nAtoms
+       call ts_read_atom_info(ts, itype, cooCart, forCart)
+       call ts_read_sf_info(ts, nsf)
+       call ts_read_sf_values(ts, nsf, sfval(1:nsf))
+       if (present(Dw)) then
+          nw = ff_get_nweights(net(itype))
+          call eval_net(net(itype), nsf, nw, sfval(1:nsf), &
+                        E_i, F_i(1:nsf), Dw_i(1:nw))
+          Dw(1:nw, itype) = Dw(1:nw, itype) - Dw_i(1:nw)/dble(nAtoms)
+       else
+          call eval_net2(net(itype), nsf, sfval(1:nsf), E_i, F_i(1:nsf))
+       end if
+       E_nn = E_nn + E_i
+       if (present(save_energies)) natoms_type(itype) = natoms_type(itype) + 1
+    end do ! iatom central atom
+
+    dE = (E_coh - E_nn)/dble(nAtoms)
+
+    if (present(save_energies)) then
+       ! save energies to file for comparison
+       E_coh = E_coh/ts%scale + dble(nAtoms)*ts%shift
+       E_nn  = E_nn/ts%scale + dble(nAtoms)*ts%shift
+       write(save_energies,'(1x,2(ES14.6,1x),I5,1x,4(ES14.6,1x))', &
+            advance='no') E_coh, E_nn, nAtoms, E_coh/dble(nAtoms), &
+            E_nn/dble(nAtoms), dE/ts%scale, dE
+       ! write out number of atoms for each species
+       do itype = 1, ts%nTypes
+          write(save_energies, '(1x,I4)', advance='no') natoms_type(itype)
+       end do
+       write(save_energies, '(1x,A)') trim(filename)
+    end if
+    if (present(dF)) dF(:,:) = 0.0d0
+
+  end subroutine eval_next_structure
+
+  !--------------------------------------------------------------------!
+
+  subroutine eval_net(net, nsf, nw, sfval, E, F, Dw)
+
+    implicit none
+
+    type(Network),                    intent(inout) :: net
+    integer,                          intent(in)    :: nsf
+    integer,                          intent(in)    :: nw
+    double precision, dimension(nsf), intent(in)    :: sfval
+    double precision,                 intent(out)   :: E
+    double precision, dimension(nsf), intent(out)   :: F
+    double precision, dimension(nw),  intent(out)   :: Dw
+
+    double precision, dimension(1) :: Ebuff
+
+    ann_values(:) = 0.0d0
+    ann_derivs(:) = 0.0d0
+    ann_jacobian(:) = 0.0d0
+    call ff_eval(net, nsf, sfval(1:nsf), 1, ann_values, ann_derivs, Ebuff)
+    call ff_deriv(net, nsf, 1, ann_derivs, ann_jacobian, F(1:nsf))
+    call ff_wderiv(net, nw, 1, ann_values, ann_derivs, ann_jacobian, Dw)
+
+    E = Ebuff(1)
+
+  end subroutine eval_net
+
+  !--------------------------------------------------------------------!
+
+  subroutine eval_net2(net, nsf, sfval, E, F)
+
+    implicit none
+
+    type(Network),                    intent(inout) :: net
+    integer,                          intent(in)    :: nsf
+    double precision, dimension(nsf), intent(in)    :: sfval
+    double precision,                 intent(out)   :: E
+    double precision, dimension(nsf), intent(out)   :: F
+
+    double precision, dimension(1) :: Ebuff
+
+    ann_values(:) = 0.0d0
+    ann_derivs(:) = 0.0d0
+    call ff_eval(net, nsf, sfval(1:nsf), 1, ann_values, ann_derivs, Ebuff)
+    call ff_deriv(net, nsf, 1, ann_derivs, ann_jacobian, F(1:nsf))
+
+    E = Ebuff(1)
+
+  end subroutine eval_net2
+
+  !--------------------------------------------------------------------!
+  !                           weight updates                           !
+  !--------------------------------------------------------------------!
+
+  subroutine update_weights(nTypes, Dw, net)
+
+    implicit none
+
+    integer,                                    intent(in)    :: nTypes
+    double precision, dimension(:,:), optional, intent(in)    :: Dw
+    type(Network),    dimension(:),             intent(inout) :: net
+
+    integer :: itype
+    integer :: nw
+
+    do itype = 1, nTypes
+       nw = ff_get_nweights(net(itype))
+       call ff_update_weights(net(itype), nw, Dw(1:nw,itype))
+    end do
+
+  end subroutine update_weights
+
+  !--------------------------------------------------------------------!
+  !      all processes (in a parallel run) must know the networks      !
+  !--------------------------------------------------------------------!
+
+  subroutine broadcast_networks()
+
+    implicit none
+
+    integer :: itype
+
+    call pp_bcast(ts%nTypes)
+    if (.not. allocated(net)) allocate(net(ts%nTypes))
+    do itype = 1, ts%nTypes
+       call pp_bcast_Network(net(itype))
+    end do
+
+  end subroutine broadcast_networks
+
+  !--------------------------------------------------------------------!
+  !            divide training / testing set over processes            !
+  !--------------------------------------------------------------------!
+
+  subroutine distribute_trnfile(isTest, nsf_max, ts, ts_trn, ts_tst)
+
+    implicit none
+
+    logical, dimension(:), intent(in)    :: isTest
+    integer,               intent(in)    :: nsf_max
+    type(TrnSet),          intent(inout) :: ts
+    type(TrnSet), target,  intent(out)   :: ts_trn
+    type(TrnSet), target,  intent(out)   :: ts_tst
+
+    integer                                 :: nTrn, nTst
+    character(len=1024)                     :: procTrnFile, procTstFile
+    integer                                 :: iproc
+    integer                                 :: ifile
+    character(len=1024)                     :: filename
+    integer                                 :: iatom, natoms
+    integer                                 :: itype, ntypes
+    integer                                 :: nsf
+    double precision, dimension(3)          :: coo, for
+    double precision, dimension(nsf_max)    :: sfval
+    !$$ double precision, dimension(3,nsf_max)  :: sfderiv
+    double precision                        :: energy
+    integer,          dimension(0:ppSize-1) :: nAtProc
+    type(TrnSet), pointer                   :: ts_p
+    double precision                        :: scale, shift
+
+    ! determine how many structures each process will receive
+    nTrn = 0
+    nTst = 0
+    do ifile = 1, ts%nStrucs
+       iproc = mod(ifile, ppSize)
+       if (iproc == ppRank) then
+          if (isTest(ifile)) then
+             nTst = nTst + 1
+          else
+             nTrn = nTrn + 1
+          end if
+       end if
+    end do
+
+    if (ppMaster) then
+       call rewind_TrnSet(ts)
+       scale = ts%scale
+       shift = ts%shift
+    end if
+    call pp_bcast(scale)
+    call pp_bcast(shift)
+
+    ! file names for process local data set files
+    procTrnFile = 'TRAIN.'//trim(io_adjustl(ppRank))
+    procTstFile = 'TEST.'//trim(io_adjustl(ppRank))
+
+    ts_trn = new_TrnSet(ts%nTypes, ts%typeName, ts%E_atom, nTrn, &
+                        procTrnFile, scale=scale, shift=shift)
+    ts_tst = new_TrnSet(ts%nTypes, ts%typeName, ts%E_atom, nTst, &
+                        procTstFile, scale=scale, shift=shift)
+
+    nAtProc(:) = 0
+    structures : do ifile = 1, ts%nStrucs
+
+       ! target process:
+       iproc = mod(ifile, ppSize)
+
+       ! target file:
+       if (isTest(ifile)) then
+          ts_p => ts_tst
+       else
+          ts_p => ts_trn
+       end if
+
+       !-----------------------------------------------!
+       ! read record and send it to the target process !
+       !-----------------------------------------------!
+
+       if (ppMaster) then
+          call ts_read_structure_info(ts, filename, natoms, ntypes, energy)
+          if (iproc == ppRank) then
+             call ts_write_structure_info(ts_p, filename, natoms, ntypes, energy)
+          else
+             call pp_send(filename, dest=iproc)
+             call pp_send(natoms,   dest=iproc)
+             call pp_send(ntypes,   dest=iproc)
+             call pp_send(energy,   dest=iproc)
+          end if
+          nAtProc(iproc) = nAtProc(iproc) + natoms
+          do iatom = 1, natoms
+             call ts_read_atom_info(ts, itype, coo, for)
+             if (iproc == ppRank) then
+                call ts_write_atom_info(ts_p, itype, coo, for)
+             else
+                call pp_send(itype, dest=iproc)
+                call pp_send(coo, 3, dest=iproc)
+                call pp_send(for, 3, dest=iproc)
+             end if
+             call ts_read_sf_info(ts, nsf)
+             call ts_read_sf_values(ts, nsf, sfval(1:nsf))
+             if (iproc == ppRank) then
+                call ts_write_sf_info(ts_p, nsf, sfval(1:nsf))
+                !$$ call ts_write_sf_info(ts_p, itype2, nsf, sfval(1:nsf), &
+                !$$                       sfderiv(1:3,1:nsf))
+             else
+                call pp_send(nsf, dest=iproc)
+                call pp_send(sfval(1:nsf), nsf, dest=iproc)
+                !$$ do isf = 1, nsf
+                !$$    call pp_send(sfderiv(1:3,isf), 3, dest=iproc)
+                !$$ end do
+             end if
+          end do ! iatom
+       end if ! ppMaster
+
+       !-----------------------------------------------!
+       ! receive record and write it to the right file !
+       !-----------------------------------------------!
+
+       if ((iproc == ppRank) .and. (.not. ppMaster)) then
+          call pp_recv(filename)
+          call pp_recv(natoms)
+          call pp_recv(ntypes)
+          call pp_recv(energy)
+          call ts_write_structure_info(ts_p, filename, natoms, ntypes, energy)
+          do iatom = 1, natoms
+             call pp_recv(itype)
+             call pp_recv(coo, 3)
+             call pp_recv(for, 3)
+             call ts_write_atom_info(ts_p, itype, coo, for)
+             call pp_recv(nsf)
+             call pp_recv(sfval(1:nsf), nsf)
+             !$$ do isf = 1, nsf
+             !$$    call pp_recv(sfderiv(1:3,isf), 3)
+             !$$ end do
+             call ts_write_sf_info(ts_p, nsf, sfval(1:nsf))
+             !$$ call ts_write_sf_info(ts_p, itype2, nsf, sfval(1:nsf), &
+             !$$                       sfderiv(1:3,1:nsf))
+          end do ! iatom
+       end if
+
+    end do structures
+
+    call close_TrnSet(ts_trn)
+    call close_TrnSet(ts_tst)
+    ts_trn = open_TrnSet(procTrnFile)
+    ts_tst = open_TrnSet(procTstFile)
+
+    if (ppMaster) then
+       ! write out info about static work load balance:
+       if (ppSize > 1) then
+          call aeio_header("Static work load balance")
+          write(ionum,*)
+          write(ionum,*) 'Number of atoms on the different processes'
+          write(ionum,*)
+          do iproc = 0, ppSize-1
+             write(ionum,'(1x,I4,2x,":",2x,I8)') iproc, nAtProc(iproc)
+          end do
+          write(ionum,*)
+       end if
+    end if
+
+  end subroutine distribute_trnfile
+
+  !--------------------------------------------------------------------!
+  !               print info about the training settings               !
+  !--------------------------------------------------------------------!
+
+  subroutine print_training_info()
+
+    implicit none
+
+    integer :: ifile, itest
+
+    call aeio_header('Training details')
+    write(ionum,*)
+
+    write(ionum,*) 'Training method         : ', trim(inp%trn_methodName)
+    select case(trim(inp%trn_method))
+    case('ekf')
+       write(ionum,*) '  Forgetting factor     : ', inp%trn_param(1)
+       write(ionum,*) '  Ini. state covariance : ', inp%trn_param(2)
+       write(ionum,*) '  Measuring noise       : ', inp%trn_param(3)
+       write(ionum,*) '  Process noise         : ', inp%trn_param(4)
+       write(ionum,*) '  Adaptive EKF threshold: ', inp%trn_param(5)
+    case('lm')
+       write(ionum,*) '  Batch size            : ', int(inp%trn_param(1))
+       write(ionum,*) '  Batch iterations      : ', int(inp%trn_param(3))
+       write(ionum,*) '  Initial learning rate : ', inp%trn_param(2)
+       write(ionum,*) '  Target error          : ', inp%trn_param(4)
+    case('online_sd')
+       write(ionum,*) '  Learning rate         : ', inp%trn_param(2)
+       write(ionum,*) '  Momentum rate         : ', inp%trn_param(1)
+    end select
+    write(ionum,*)
+    write(ionum,*) 'Number of iterations    : ', trim(io_adjustl(inp%trn_steps))
+    write(ionum,*)
+    write(ionum,*) 'Training structures     : ', trim(io_adjustl(nTrain))
+    write(ionum,*) 'Testing  structures     : ', trim(io_adjustl(nTest))
+    write(ionum,*)
+
+    if (restarted) then
+       write(ionum,'(1x,"Testing set (restarted from previous run): ")')
+    else
+       write(ionum,'(1x,"Testing set : ")')
+    end if
+    itest = 0
+    do ifile = 1, ts%nStrucs
+       if (isTest(ifile)) then
+          if (mod(itest,8) == 0) then
+             write(ionum,*)
+          end if
+          itest = itest + 1
+          write(ionum, '(I8,1x)', advance='no') ifile
+       end if
+    end do
+    write(ionum,*)
+    write(ionum,*)
+
+  end subroutine print_training_info
+
+  !--------------------------------------------------------------------!
+  !                print header info for training steps                !
+  !--------------------------------------------------------------------!
+
+  subroutine print_training_header(nIters, method)
+
+    implicit none
+
+    integer,          intent(in) :: nIters
+    character(len=*), intent(in) :: method
+
+    call aeio_header("Training process")
+    write(ionum,*)
+    write(ionum,*) 'Weight optimization for ' // trim(io_adjustl(nIters)) &
+         // ' epochs using the ' // trim(adjustl(method)) &
+         // ' method.'
+    write(ionum,*)
+
+    call opt_print_info()
+
+    write(ionum,*)
+    write(ionum,'(8x,A30,2x,A30)') &
+         '|------------TRAIN-----------|', &
+         '|------------TEST------------|'
+    write(ionum,'(1x,A5,2x,A14,2x,A14,2x,A14,2x,A14)') &
+         'epoch', 'MAE', '<RMSE>', 'MAE', '<RMSE>'
+
+  end subroutine print_training_header
+
+  !------------------ energies at current iteration -------------------!
+
+  subroutine print_energies(istep, MAE_trn, RMSE_trn, MAE_tst, RMSE_tst)
+
+    implicit none
+
+    integer,          intent(in) :: istep
+    double precision, intent(in) :: MAE_trn
+    double precision, intent(in) :: RMSE_trn
+    double precision, intent(in) :: MAE_tst
+    double precision, intent(in) :: RMSE_tst
+
+    write(ionum,'(1x,I5,2x,ES14.6,2x,ES14.6,2x,ES14.6,2x,ES14.6," <")') &
+          istep, MAE_trn, RMSE_trn, MAE_tst, RMSE_tst
+
+  end subroutine print_energies
+
+  !--------------------------------------------------------------------!
+  !  save all networks to files (incl. structural fingerprint set-up)  !
+  !--------------------------------------------------------------------!
+
+  subroutine save_all_networks(verbose, iter,directoryname)
+
+    implicit none
+
+    logical, optional, intent(in) :: verbose
+    integer, optional, intent(in) :: iter
+    character(len =*),optional,intent(in)::directoryname
+
+    integer :: itype
+    integer :: u_sav
+    character(len=10) :: enum
+    character(len = 100) ::filename
+
+    if (.not. allocated(net)) return
+    if (.not. allocated(stp)) return
+
+    if (present(directoryname)) then
+      filename = "./"//directoryname
+    else
+      filename = "./"
+    end if
+
+    if (present(verbose)) then
+       call aeio_header("Storing networks")
+       write(ionum,*)
+    end if
+
+    if (present(iter)) then
+       write(enum,'("-",I0.5)') iter
+    else
+       enum = " "
+    end if
+
+    
+    u_sav = io_unit()
+    do itype = 1, ts%nTypes
+       if (present(verbose)) then
+          write(ionum,*) 'Saving the ', trim(ts%typeName(itype)), &
+               ' network to file : ', trim(inp%netFile(itype)) // trim(enum)
+       end if
+
+       open(u_sav, file=trim(filename)//"/"//trim(inp%netFile(itype))//trim(enum), status='replace', &
+            action='write', form='unformatted')
+       call save_Network(net(itype), unit=u_sav)
+       call save_Setup(stp(itype), unit=u_sav)
+       call save_TrnSet_info(ts, unit=u_sav)
+       close(u_sav)
+    end do
+    if (present(verbose)) write(ionum,*)
+
+  end subroutine save_all_networks
+
+  !--------------------------------------------------------------------!
+  !                    save all structural energies                    !
+  !--------------------------------------------------------------------!
+
+  subroutine save_all_energies(ts_trn, ts_tst, nTrain, nTest, nsf_max, &
+                               nw_max, net)
+
+    implicit none
+
+    type(TrnSet),                intent(inout) :: ts_trn
+    type(TrnSet),                intent(inout) :: ts_tst
+    integer,                     intent(in)    :: nTrain
+    integer,                     intent(in)    :: nTest
+    integer,                     intent(in)    :: nsf_max
+    integer,                     intent(in)    :: nw_max
+    type(Network), dimension(:), intent(inout) :: net
+
+    character(len=PATHLEN) :: fname
+    character(len=64)      :: frmt, str
+    character(len=1024)    :: header
+    integer                :: u_sav, itype
+    double precision       :: MAE_trn, SSE_trn, RMSE_trn
+    double precision       :: MAE_tst, SSE_tst, RMSE_tst
+
+    if (ppMaster) then
+       call aeio_header("Storing final energies")
+       write(ionum,*)
+       write(ionum,*) 'Energies of training structures : energies.train.PROCESS'
+       write(ionum,*) 'Energies of testing structures  : energies.test.PROCESS'
+       write(ionum,*) '(Manually concatenate the files from different processes.)'
+       write(ionum,*)
+    end if
+
+    u_sav = io_unit()
+
+    ! file header with column description
+    header = "  Ref(eV)        ANN(eV)      #atoms  Ref(eV/atom)" &
+             // "   ANN(eV/atom) Ref-ANN(eV/atom)    Cost-Func"
+    frmt = '(2x,"#",A' // trim(io_adjustl(TYPELEN)) // ')'
+    write(str, frmt) ts_trn%typeName(1)
+    header = trim(header) // " " // trim(str)
+    do itype = 2, ts_trn%nTypes
+       write(str, frmt) ts_trn%typeName(itype)
+       header = trim(header) // trim(str)
+    end do
+    header = trim(header) // "    Path-of-input-file"
+
+    ! training set
+    fname = 'energies.train.' // trim(io_adjustl(ppRank))
+    open(u_sav, file=trim(fname), status='replace', action='write')
+    write(u_sav, '(A)') trim(header)
+    call eval_entire_trainset(ts_trn, nTrain, nsf_max, nw_max, net, &
+                              MAE_trn, SSE_trn, save_energies=u_sav)
+    close(u_sav)
+
+    ! testing set
+    fname = 'energies.test.' // trim(io_adjustl(ppRank))
+    open(u_sav, file=trim(fname), status='replace', action='write')
+    write(u_sav, '(A)') trim(header)
+    call eval_entire_trainset(ts_tst, nTest, nsf_max, nw_max, net, &
+                              MAE_tst, SSE_tst, save_energies=u_sav)
+    close(u_sav)
+
+    if (ppMaster) then
+       MAE_trn  = 1000.0d0*MAE_trn/ts_trn%scale
+       RMSE_trn = 1000.0d0*sqrt(2.0d0*SSE_trn/dble(nTrain))/ts_trn%scale
+       MAE_tst  = 1000.0d0*MAE_tst/ts_tst%scale
+       RMSE_tst = 1000.0d0*sqrt(2.0d0*SSE_tst/dble(nTest))/ts_tst%scale
+
+       write(ionum,'(1x,"Final MAE of training set  = ",F8.1," meV/atom")') MAE_trn
+       write(ionum,'(1x,"Final MAE of testing set   = ",F8.1," meV/atom")') MAE_tst
+       write(ionum,*)
+       write(ionum,'(1x,"Final RMSE of training set = ",F8.1," meV/atom")') RMSE_trn
+       write(ionum,'(1x,"Final RMSE of testing set  = ",F8.1," meV/atom")') RMSE_tst
+       write(ionum,*)
+    end if
+
+  end subroutine save_all_energies
+
+  !--------------------------------------------------------------------!
+  !                 maximum number of basis functions                  !
+  !--------------------------------------------------------------------!
+
+  function max_num_sf() result(nsf)
+
+    implicit none
+
+    integer :: nsf
+    integer :: itype
+
+    nsf = 0
+    do itype = 1, ts%nTypes
+       nsf = max(nsf, stp(itype)%nsf)
+    end do
+
+  end function max_num_sf
+
+  !--------------------------------------------------------------------!
+  !                 maximum number of network nodes                    !
+  !--------------------------------------------------------------------!
+
+  subroutine get_num_nodes(ts, nnodes_max)
+
+    implicit none
+
+    type(TrnSet), intent(in)  :: ts
+    integer,      intent(out) :: nnodes_max
+
+    integer :: itype
+
+    nnodes_max = 0
+    do itype = 1, ts%nTypes
+       nnodes_max = max(nnodes_max, net(itype)%nvalues)
+    end do
+
+  end subroutine get_num_nodes
+
+  !--------------------------------------------------------------------!
+  !                 maximum number of network weights                  !
+  !--------------------------------------------------------------------!
+
+  subroutine get_num_weights(ts, nw_max, nw_tot)
+
+    implicit none
+
+    type(TrnSet), intent(in)  :: ts
+    integer,      intent(out) :: nw_max, nw_tot
+
+    integer :: nw, itype
+
+    nw_max = 0
+    nw_tot = 0
+    do itype = 1, ts%nTypes
+       nw = ff_get_nweights(net(itype))
+       nw_max = max(nw_max, nw)
+       nw_tot = nw_tot + nw
+    end do
+
+  end subroutine get_num_weights
+
+  !--------------------------------------------------------------------!
+  !           decide, which structures enter the testing set           !
+  !--------------------------------------------------------------------!
+
+  subroutine decide_testing_set(nFiles, testpercent, nTrain, nTest, &
+                                isTest, restarted)
+
+    implicit none
+
+    integer,                    intent(in)  :: nFiles
+    double precision,           intent(in)  :: testpercent
+    integer,                    intent(out) :: nTrain
+    integer,                    intent(out) :: nTest
+    logical, dimension(nFiles), intent(out) :: isTest
+    logical,                    intent(out) :: restarted
+
+    logical          :: fexists
+    double precision :: r
+    integer          :: ifile, itrain, itest
+
+    inquire(file=RNG_STATE_FILE, exist=fexists)
+    if (fexists) then
+       restarted = .true.
+       call random_load_state(file=RNG_STATE_FILE, unit=io_unit())
+    else
+       restarted = .false.
+       call random_save_state(file=RNG_STATE_FILE, unit=io_unit())
+    end if
+
+    nTrain = ceiling((1.0d0 - testpercent/100.0d0)*dble(nFiles))
+    nTest  = nFiles - nTrain
+
+    itrain = 0
+    itest  = 0
+    do ifile = 1, nFiles
+       if (itest == nTest) then
+          itrain = itrain + 1
+          isTest(ifile) = .false.
+       else if (itrain == nTrain) then
+          itest = itest + 1
+          isTest(ifile) = .true.
+       else
+          call random_number(r)
+          if (r <= testpercent/100.0d0) then
+             itest = itest + 1
+             isTest(ifile) = .true.
+          else
+             itrain = itrain + 1
+             isTest(ifile) = .false.
+          end if
+       end if
+    end do
+
+    ! re-initialize random number generator, in case it is used for
+    ! something else afterwards
+    call random_reinit()
+
+  end subroutine decide_testing_set
+
+end subroutine train_sub
diff -Naru src/ext/lclist.f90 src_modified/ext/lclist.f90
--- src/ext/lclist.f90	2025-04-08 11:32:06.106110012 +0900
+++ src_modified/ext/lclist.f90	2025-04-08 13:32:08.763414197 +0900
@@ -129,7 +129,9 @@
 
     ! set up half start of vectors pointing to cells within range of r_max:
     nCvecs = 0
+    allocate(Cvec(3,nCvecs))
     call translation_vectors(r_max, gridVec, nCvecs, Cvec, nc=nCells, pbc=pbc)
+    deallocate(Cvec)
     allocate(Cvec(3,nCvecs))
     call translation_vectors(r_max, gridVec, nCVecs, cVec, nc=nCells, pbc=pbc)
 
@@ -137,7 +139,9 @@
     ! images of the unit cell within range of r_max:
     nTvecs = 0
     if (pbc) then
+       allocate(Tvec(3,nCvecs))
        call translation_vectors(r_max, latticeVec, nTvecs, Tvec)
+       deallocate(Tvec)
        allocate(Tvec(3,nTvecs))
        call translation_vectors(r_max, latticeVec, nTvecs, Tvec)
     end if
@@ -526,6 +530,7 @@
     double precision                         :: Rc, Rc2, dist2
     double precision, dimension(3)           :: coo1, coo2, cart
     integer                                  :: nblist_stat
+    logical :: type_match
 
     if (.not. isInit) then
        write(0,*) "Error: module not initialized in `nbdist'."
@@ -566,9 +571,16 @@
     end if
 
     ! (2) check distance do the periodic images of the central atom:
-
+    if (present(itype)) then
+      type_match = (atomType(iatom) == itype)
+    else
+      type_match = .false.
+    end if
     nnb_tot = 0
-    if ( (.not. present(itype)) .or. (atomType(iatom) == itype)) then
+    
+    
+    !if ( (.not. present(itype)) .or. (atomType(iatom) == itype)) then
+    if ( (.not. present(itype)) .or. type_match ) then
        do iT = 1, nTvecs
           cart(1:3) = matmul(latticeVec, dble(Tvec(1:3,iT)))
           dist2 = sum(cart*cart)
@@ -601,7 +613,14 @@
 
     do inb = 1, nnb2
        iat = nblist_loc(inb)
-       if ( present(itype) .and. (atomType(iat) /= itype)) cycle
+       if (present(itype)) then
+         type_match = (atomType(iat) /= itype)
+       else
+         type_match = .false.
+       end if
+
+       !if ( present(itype) .and. (atomType(iat) /= itype)) cycle
+       if ( present(itype) .and. type_match) cycle
        ! in home unit cell:
        coo2(1:3) = matmul(latticeVec, cooLatt(1:3,iat))
        cart(1:3) = coo2(1:3) - coo1(1:3)
diff -Naru src/generate_MPI.f90 src_modified/generate_MPI.f90
--- src/generate_MPI.f90	1970-01-01 09:00:00.000000000 +0900
+++ src_modified/generate_MPI.f90	2025-04-08 13:27:27.572785785 +0900
@@ -0,0 +1,591 @@
+!-----------------------------------------------------------------------
+!      generate.f90 - generate training sets for use with train.x
+!-----------------------------------------------------------------------
+!+ This file is part of the AENET package.
+!+
+!+ Copyright (C) 2012-2018 Nongnuch Artrith and Alexander Urban
+!+
+!+ This Source Code Form is subject to the terms of the Mozilla Public
+!+ License, v. 2.0. If a copy of the MPL was not distributed with this
+!+ file, You can obtain one at http://mozilla.org/MPL/2.0/.
+!+
+!+ This program is distributed in the hope that it will be useful, but
+!+ WITHOUT ANY WARRANTY; without even the implied warranty of
+!+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+!+ Mozilla Public License, v. 2.0, for more details.
+!-----------------------------------------------------------------------
+! 2011-10-19 Alexander Urban (AU), Nongnuch Artrith (NA)
+!-----------------------------------------------------------------------
+
+program generate_MPI
+
+  use aeio,     only: aeio_readline,        &
+                      aeio_header,          &
+                      aeio_timestamp,       &
+                      aeio_print_copyright, &
+                      PATHLEN, LINELEN
+
+  use geometry, only: geo_init,          &
+                      geo_final,         &
+                      geo_itype_of_name, &
+                      geo_type_conv,     &
+                      pbc,               &
+                      latticeVec,        &
+                      nAtoms,            &
+                      nTypes,            &
+                      atomType,          &
+                      atomTypeName,      &
+                      cooLatt,           &
+                      cooCart,           &
+                      forCart,           &
+                      hasEnergy,         &
+                      hasForces,         &
+                      cohesiveEnergy,    &
+                      totalEnergy
+
+  use input,    only: InputData,         &
+                      read_InpGenerate,  &
+                      del_InputData
+
+  use io,       only: io_adjustl,        &
+                      io_center,         &
+                      io_lower,          &
+                      io_readnext,       &
+                      io_unit
+
+  use lclist,   only: lcl_init,          &
+                      lcl_final,         &
+                      lcl_print_info,    &
+                      lcl_nmax_nbdist,   &
+                      lcl_nbdist_cart
+
+  use sfsetup,  only: Setup,                 &
+                      read_Setup_parameters, &
+                      save_Setup,            &
+                      del_Setup,             &
+                      stp_init,              &
+                      stp_final,             &
+                      stp_get_range,         &
+                      stp_print_info,        &
+                      stp_eval,              &
+                      nsf_max
+
+  use timing,   only: tng_init,          &
+                      tng_final,         &
+                      tng_timing,        &
+                      tng_timing2,       &
+                      tng_timing3,       &
+                      tng_dump
+
+  use trainset, only: TrnSet,                     &
+                      ts_print_info
+
+  use trainset_MPI, only: new_TrnSet_MPI,             &
+                          close_TrnSet_MPI,           &
+                          ts_write_header_MPI,        &
+                          ts_write_sf_info_MPI,       &
+                          ts_write_atom_info_MPI,     &
+                          ts_write_structure_info_MPI,&
+                          ts_parallel_footer_MPI
+
+  use parallel,    only: pp_init,                &
+                         pp_final,               &
+                         pp_bcast,               &
+                         pp_barrier,             &
+                         ppMaster,               &
+                         ppRank,                 &
+                         ppSize,                 &
+                         pp_bcast_InputData,     &
+                         pp_bcast_Setup
+
+  implicit none
+
+  !--------------------------------------------------------------------!
+  ! stp(i)         structural fingerprint basis setup for atom type i  !
+  ! r_min, r_max   lower and upper bound for atomic interactions       !
+  ! ts             training set reference                              !
+  !                                                                    !
+  ! nnb_max, nnb   max. and actual number of neighboring atoms         !
+  ! nbcoo(i,j)     i-th component of the coordinates of the j-th       !
+  !                neighboring atom                                    !
+  ! nbdist(i)      distance of the i-th neighbor                       !
+  !                                                                    !
+  ! sfval(i)         value of the i-th basis function                  !
+  ! sfderiv_i(i,j)   i-th component of the derivative of the j-th SF   !
+  !                  with respect to the central atom                  !
+  !                  sfderiv_i(3,nsf_max)                              !
+  ! sfderiv_j(i,j,k) i-th component of the derivative of the j-th SF   !
+  !                  with respect to the coordinates of atom k         !
+  !                  sfderiv_j(3,nsf_max,nnb_max)                      !
+  !                                                                    !
+  ! E_coh          cohesive energy                                     !
+  ! nFiles_inv     = 1/inp%nStrucs                                     !
+  !                                                                    !
+  ! inFile         name of the input file for the generate.x program   !
+  ! cooFile        name of the currently active structure file         !
+  ! keyword        the last keyword read from the input file           !
+  !                                                                    !
+  ! do_debug       if .true., additional files containing debugging    !
+  !                info will be created                                !
+  !                                                                    !
+  ! u_*            file units                                          !
+  !--------------------------------------------------------------------!
+
+  type(InputData)                                :: inp
+
+  type(Setup),       dimension(:),   allocatable :: stp
+  double precision                               :: r_min, r_max
+  type(TrnSet)                                   :: ts
+
+  integer                                        :: nnb_max, nnb
+  double precision,  dimension(:,:), allocatable :: nbcoo
+  double precision,  dimension(:),   allocatable :: nbdist
+  integer,           dimension(:),   allocatable :: nbtype
+
+  double precision, dimension(:),     allocatable :: sfval
+  double precision, dimension(:,:),   allocatable :: sfderiv_i
+  double precision, dimension(:,:,:), allocatable :: sfderiv_j
+
+  double precision                               :: E_coh
+  integer                                        :: ifile
+  double precision                               :: nFiles_inv
+
+  character(len=PATHLEN)                         :: inFile
+  character(len=PATHLEN)                         :: cooFile
+  character(len=LINELEN)                         :: keyword
+
+  integer                                        :: itype1
+  integer                                        :: itype, iatom
+
+  integer                                        :: iline
+  character(len=1024)                            :: line
+
+  integer                                        :: u_in, u_tng
+  logical                                        :: do_debug = .false.
+  integer                                        :: u_dbg, idbg
+
+  integer :: i
+
+  ! timing registers
+  integer, parameter :: R_GEO = 1, R_NBL = 2, R_SF = 3
+
+  logical :: stopnow
+
+  !-------------------------- initialization --------------------------!
+
+  if (ppMaster) then
+     call system( 'rm -f ts.* 2> /dev/null' )
+  end if
+
+  call initialize_MPI(inFile)
+
+  if (ppMaster) inp = read_InpGenerate(inFile)
+  call pp_bcast_InputData(inp)
+!  inp = read_InpGenerate(inFile)
+
+  
+
+  allocate(stp(inp%nTypes))
+  call load_symmfunc_setups_MPI(inp, stp)
+  ! call parse_input(inFile)
+  
+  
+
+  if (inp%do_timing .and. ppMaster ) then
+     u_tng = io_unit()
+     call tng_init(unit=u_tng, file='generate.time', registers=3)
+     write(*,*) 'Timing info will be written to: ', 'generate.time'
+     write(*,*)
+  end if
+  if (do_debug .and. ppMaster ) then
+     u_dbg = io_unit()
+     open(u_dbg, file='generate.debug', status='replace', action='write')
+  end if
+
+  
+
+  ! get interaction range and max. number of atoms within range
+  call stp_get_range(inp%nTypes, stp, r_min, r_max)
+  nnb_max = lcl_nmax_nbdist(r_min, r_max)
+  allocate(nbcoo(3,nnb_max), nbdist(nnb_max), nbtype(nnb_max))
+
+  ! initialize workspace for structural fingerprint basis:
+  call stp_init(inp%nTypes, stp, nnb_max)
+  if (inp%do_timing .and. ppMaster) call tng_timing('Structural fingerprint basis initialized.')
+
+  ! allocate workspace for basis function evaluation:
+  allocate(sfval(nsf_max), sfderiv_i(3,nsf_max), sfderiv_j(3,nsf_max,nnb_max))
+  sfval(:) = 0.0d0
+  sfderiv_i(:,:) = 0.0d0
+  sfderiv_j(:,:,:) = 0.0d0
+  
+
+  if (ppMaster) then
+     call aeio_header('Generation of training set started')
+     write(ionum,*)
+
+     write(ionum,*) 'Number of atom types  : ', trim(io_adjustl(inp%nTypes))
+     write(ionum,'(1x,"types                 : ")', advance='no')
+     do itype = 1, inp%nTypes
+        if (mod(itype,7) == 0) write(*,'(29x)')
+        write(*,'(A5,1x)', advance='no') inp%typeName(itype)
+     end do
+     write(ionum,*)
+     write(ionum,*) "Number of structures  : ", trim(io_adjustl(inp%nStrucs))
+     write(ionum,*)
+  end if
+
+  !-------------- write basis function settings to stdout -------------!
+
+  if (ppMaster) then
+     call aeio_header("Structural fingerprint basis set-up")
+     write(*,*)
+
+     do itype1 = 1, inp%nTypes
+        call stp_print_info(stp(itype1))
+     end do
+  end if
+
+  !----------- write training set header to the output file -----------!
+
+  ts = new_TrnSet_MPI(inp%nTypes, inp%typeName, inp%atomicEnergy, &
+                      inp%nStrucs, trim(inp%outFileName))
+
+  if (inp%do_timing .and. ppMaster) call tng_timing('Training set file started.')
+
+  !------------------ iterate over coordinates files ------------------!
+
+  if (ppMaster) then
+     call aeio_header("Adding structures to the training set")
+     write(*,*)
+  end if
+
+  u_in = io_unit()
+  open(u_in, file=inFile, status='old', action='read')
+  rewind(u_in)
+
+  iline = 0
+  do
+     ! forward until the FILES keyword:
+     call aeio_readline(u_in, iline, line)
+     read(line,*) keyword
+     if (trim(keyword) == 'FILES') then
+        read(u_in,*)
+        exit
+     end if
+  end do
+
+  ! header for stdout
+  if (ppMaster) then
+     write(*,'("#",A6,2x,A6,2x,A6,2x,A15,2x,A)') &
+          'N', 'nAtoms', 'nTypes', 'E/atom', 'structure file (xsf)'
+  end if
+
+  stopnow = .false.
+
+  nFiles_inv = 1.0d0/dble(inp%nStrucs)
+  structures : do ifile = 1, inp%nStrucs
+
+     if (inp%do_timing .and. ppMaster) call tng_timing('Structure: '// io_adjustl(ifile))
+
+     call aeio_readline(u_in, iline, line)
+     cooFile = trim(line)
+
+     if ( mod(ifile-1,ppSize) .ne. ppRank ) cycle
+
+     call geo_init(cooFile, 'xsf')
+     if (inp%do_timing) call tng_timing3(register=R_GEO)
+     if (.not. (hasForces .and. hasEnergy)) then
+        write(0,*) ">>>", hasForces, hasEnergy
+        write(0,*) "Error: incomplete output data in : ", trim(cooFile)
+        stopnow = .true.
+     end if
+
+     call pp_bcast(stopnow)
+     if (stopnow) then
+        call finalize_MPI()
+        stop
+     end if
+
+     if (nTypes > inp%nTypes) then
+        write(*,*) 'Skipping ', trim(adjustl(cooFile)), &
+                   ': too many atomic species'
+        call geo_final()
+        cycle structures
+     end if
+
+     if (abs(cohesiveEnergy) /= 0.0d0) then
+        E_coh = cohesiveEnergy
+     else
+        ! if only the total energy is available, we have to calculate
+        ! the cohesive energy at this point
+        E_coh = totalEnergy
+        do iatom = 1, nAtoms
+           itype1 = atomType(iatom)
+           itype1 = geo_type_conv(itype1, nTypes, atomTypeName, &
+                                  inp%nTypes, inp%typeName)
+           E_coh = E_coh - inp%atomicEnergy(itype1)
+        end do
+     end if
+
+     write(*,'(1x,I6,2x,I6,2x,I6,2x,ES15.8,2x,A)') &
+          ifile, nAtoms, nTypes, E_coh/dble(nAtoms), &
+          trim(adjustl(cooFile))
+
+     call lcl_init(r_min, r_max, latticeVec, nAtoms, atomType, cooLatt, pbc)
+     if (inp%do_timing .and. ppMaster) call tng_timing3(register=R_NBL)
+
+     ! write structure info (atoms, types, energy) to training set file:
+     call ts_write_structure_info_MPI(ts, cooFile, nAtoms, nTypes, E_coh, ifile)
+
+     atoms : do iatom = 1, nAtoms
+
+        ! determine the training atom type of atom `iatom' in global
+        ! index terms
+        itype1 = atomType(iatom)
+        itype1 = geo_type_conv(itype1, nTypes, atomTypeName, &
+                               inp%nTypes, inp%typeName)
+
+        ! assert that atom type is included in the set-ups:
+        if (itype1 == 0) then
+           write(0,*) "Error: not a valid structure    : ", trim(cooFile)
+           write(0,*) "       Additional species found."
+           call finalize_MPI()
+           stop
+        end if
+
+        ! write atom info (species, forces) to training set file:
+        call ts_write_atom_info_MPI(ts, itype1, cooCart(iatom), forCart(iatom), ifile)
+
+        ! get all atoms within cut-off:
+        nnb = nnb_max
+        call lcl_nbdist_cart(iatom, nnb, nbcoo, nbdist, r_cut=r_max, nbtype=nbtype)
+        if (inp%do_timing .and. ppMaster) call tng_timing3(register=R_NBL)
+!        write(*,'(1x,I6,2x,A2,2x,I6)') &
+!             iatom, trim(atomTypeName(atomType(iatom))), nnb
+
+        ! convert atom types to global index:
+        do i = 1, nnb
+           nbtype(i) = geo_type_conv(nbtype(i), nTypes, atomTypeName, &
+                                    inp%nTypes, inp%typeName)
+           if (nbtype(i) == 0) then
+              write(0,*) "Error: atom type not found in setup."
+              call finalize_MPI()
+              stop
+           end if
+        end do
+
+        ! evaluate the structural fingerprint basis function set-up:
+        call stp_eval(itype1, cooCart(iatom), nnb, nbcoo, nbtype, &
+                      stp(itype1), sfval=sfval)
+
+        if (do_debug .and. ppMaster) then
+           do idbg = 1, stp(itype1)%nsf
+              write(u_dbg,'(1x,ES15.8,1x)', advance='no') sfval(idbg)
+           end do
+           write(u_dbg,*)
+        end if
+
+        if (inp%do_timing .and. ppMaster) call tng_timing3(register=R_SF)
+
+        ! write basis function values and derivatives
+        ! to the training set file:
+        call ts_write_sf_info_MPI(ts, stp(itype1)%nsf, sfval(1:stp(itype1)%nsf), ifile)
+
+     end do atoms
+
+     if (inp%do_timing .and. ppMaster) then
+        call tng_dump(R_GEO, 'time spent reading geometries (so far)')
+        call tng_dump(R_NBL, 'time spent in the neighbor list (so far)')
+        call tng_dump(R_SF,  'time spent evaluating structural fingerprints (so far)')
+     end if
+
+     call lcl_final()
+     call geo_final()
+
+  end do structures
+  write(*,*)
+
+  if (inp%do_timing) then
+     call tng_timing('Loop over structures done.')
+     call tng_dump(R_GEO, 'total time spent reading geometries')
+     call tng_dump(R_NBL, 'total time spent in the neighbor list')
+     call tng_dump(R_SF,  'total time spent evaluating structural fingerprints')
+  end if
+
+  !--------- save basis function setups with final statistics ---------!
+
+  if (ppMaster) call ts_print_info(ts)
+
+  !----------------------------- finalize -----------------------------!
+
+  deallocate(nbcoo, nbdist, nbtype)
+  close(u_in)
+
+  call ts_parallel_footer_MPI(ts, stp)
+
+  call close_TrnSet_MPI(ts, stp=stp(1:inp%nTypes))
+  call finalize_MPI()
+
+  if (ppMaster) then
+   call system( 'cat ts.header > '//adjustl(trim(inp%outFileName)) )
+
+   do ifile = 1, inp%nStrucs
+      call ts_write_structure_info_MPI(ts, cooFile, nAtoms, nTypes, E_coh, ifile)
+      
+
+   end do
+
+   call system( 'cat ts.footer >>' // adjustl(trim(inp%outFileName)) )
+
+
+     call system( 'cat ts.header > '//adjustl(trim(inp%outFileName)) )
+     do ifile = 1, inp%nStrucs
+        call system( 'cat ts.'//io_adjustl(ifile)//' >> '// adjustl(trim(inp%outFileName)) )
+     end do
+     call system( 'cat ts.footer >>' // adjustl(trim(inp%outFileName)) )
+  end if
+
+contains !=============================================================!
+
+
+  subroutine initialize_MPI(inFile)
+
+    implicit none
+
+    character(len=*), intent(out) :: inFile
+
+    integer :: nargs
+    logical :: fexists
+    logical :: stopnow
+
+    call pp_init()
+
+    stopnow = .false.
+
+    if (ppMaster) then
+
+       call aeio_header("generate.x - training set generation", char='=')
+       write(*,*)
+
+       call aeio_print_copyright('2015-2018', 'Nongnuch Artrith and Alexander Urban')
+
+       nargs = command_argument_count()
+       if (nargs < 1) then
+          write(0,*) "Error: No input file provided."
+          call print_usage()
+          stopnow = .true.
+       end if
+
+       call get_command_argument(1, value=inFile)
+       inquire(file=trim(inFile), exist=fexists)
+       if (.not. fexists) then
+          write(0,*) "Error: File not found: ", trim(inFile)
+          stopnow = .true.
+       end if
+
+    end if
+
+    call pp_bcast(stopnow)
+    if (stopnow) then
+       call finalize_MPI()
+       stop
+    end if
+
+    call pp_bcast(inFile)
+
+  end subroutine initialize_MPI
+
+  !--------------------------------------------------------------------!
+
+  subroutine finalize_MPI()
+
+    implicit none
+
+    integer :: itype
+
+    if (allocated(sfval)) then
+       deallocate(sfval, sfderiv_i, sfderiv_j)
+    end if
+
+    if (allocated(stp)) then
+       call stp_final(inp%nTypes, stp)
+       do itype = 1, inp%nTypes
+          call del_Setup(stp(itype))
+       end do
+       deallocate(stp, inp%typeName, inp%atomicEnergy)
+    end if
+
+    if (ts%init) call close_TrnSet_MPI(ts)
+
+    if (allocated(nbcoo)) deallocate(nbcoo, nbdist)
+
+    if (inp%do_timing .and. ppMaster ) call tng_final()
+    if (do_debug .and. ppMaster )  close(u_dbg)
+
+    if (ppMaster) then
+       call aeio_header(aeio_timestamp(), char=' ')
+       call aeio_header("Training set generation done.", char='=')
+    end if
+
+    call pp_final()
+
+  end subroutine finalize_MPI
+
+  !--------------------------------------------------------------------!
+
+  subroutine print_usage()
+
+    implicit none
+
+    write(*,*)
+    write(*,*) "generate.x -- Generate training sets for use with `train.x'"
+    write(*,'(1x,70("-"))')
+    write(*,*) 'Usage: generate.x <input-file>'
+    write(*,*)
+    write(*,*) 'See the documentation or the source code for a description of the '
+    write(*,*) 'input file format.'
+    write(*,*)
+
+  end subroutine print_usage
+
+  !--------------------------------------------------------------------!
+
+  subroutine load_symmfunc_setups_MPI(inp, stp)
+
+    implicit none
+
+    type(InputData),           intent(in)  :: inp
+    type(Setup), dimension(:), intent(out) :: stp
+    logical :: stopnow
+    integer :: i
+
+    stopnow = .false.
+    
+   
+    if(ppMaster) then 
+      do i = 1, inp%nTypes
+         stp(i) = read_Setup_parameters(inp%setupFile(i), inp%typeName(:))
+         if (.not. (trim(stp(i)%atomtype) == trim(inp%typeName(i)))) then
+            write(0,*) "Error: Inconsistent atom type in setup:"
+            write(0,*) "       type expected : ", trim(inp%typeName(i))
+            write(0,*) "       type found    : ", trim(stp(i)%atomtype)
+            stopnow = .true.
+         end if
+      end do
+   end if
+   
+
+   do i = 1, inp%nTypes
+      call pp_bcast_Setup(stp(i))
+   end do
+
+    call pp_bcast(stopnow)
+    if (stopnow) then
+       call finalize_MPI()
+       stop
+    end if
+
+  end subroutine load_symmfunc_setups_MPI
+
+end program generate_MPI
diff -Naru src/generate_test.f90 src_modified/generate_test.f90
--- src/generate_test.f90	1970-01-01 09:00:00.000000000 +0900
+++ src_modified/generate_test.f90	2025-04-08 13:27:27.572785785 +0900
@@ -0,0 +1,11 @@
+program main
+    implicit none
+    include 'mpif.h'
+    integer::ierr
+    call mpi_init(ierr)
+    call set_mpi_aenet( mpi_comm_world )
+    write(*,*) "generate test"
+    call generate_sub_MPI( 'generate.in', 11 )
+    call mpi_finalize(ierr)
+
+end program
\ No newline at end of file
diff -Naru src/makefiles/Makefile.gfortran_mkl_mpi src_modified/makefiles/Makefile.gfortran_mkl_mpi
--- src/makefiles/Makefile.gfortran_mkl_mpi	2025-04-08 11:32:06.109110110 +0900
+++ src_modified/makefiles/Makefile.gfortran_mkl_mpi	2025-04-08 13:27:27.572785785 +0900
@@ -26,7 +26,8 @@
 DEBUG    =
 FCFLAGS  = -DPARALLEL -O2 -pedantic -fexternal-blas $(DEBUG)
 LDFLAGS  = -static-libgfortran $(DEBUG)
-NUMLIB   = -Wl,--start-group \
+NUMLIB   = -lmkl_intel_lp64 -lmkl_core -lmkl_sequential -lpthread
+# -Wl,--start-group \
            $(MKLROOT)/lib/intel64/libmkl_intel_lp64.a \
            $(MKLROOT)/lib/intel64/libmkl_core.a \
            $(MKLROOT)/lib/intel64/libmkl_sequential.a \
diff -Naru src/makefiles/Makefile.gfortran_mkl_mpi_mac src_modified/makefiles/Makefile.gfortran_mkl_mpi_mac
--- src/makefiles/Makefile.gfortran_mkl_mpi_mac	1970-01-01 09:00:00.000000000 +0900
+++ src_modified/makefiles/Makefile.gfortran_mkl_mpi_mac	2025-04-08 13:27:27.572785785 +0900
@@ -0,0 +1,48 @@
+#-*- mode: makefile -*-
+#-----------------------------------------------------------------------
+#                    GNU Fortran Compiler + MPI
+#-----------------------------------------------------------------------
+#+ This file is part of the AENET package.
+#+
+#+ Copyright (C) 2012-2018 Nongnuch Artrith and Alexander Urban
+#+
+#+ This Source Code Form is subject to the terms of the Mozilla Public
+#+ License, v. 2.0. If a copy of the MPL was not distributed with this
+#+ file, You can obtain one at http://mozilla.org/MPL/2.0/.
+#+
+#+ This program is distributed in the hope that it will be useful, but
+#+ WITHOUT ANY WARRANTY; without even the implied warranty of
+#+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#+ Mozilla Public License, v. 2.0, for more details.
+#-----------------------------------------------------------------------
+# 2015-05-26 Alexander Urban (AU) and Nongnuch Artrith (NA)
+#-----------------------------------------------------------------------
+
+SUFFIX   = gfortran_mkl_mpi
+
+OMPI_FC := gfortran
+FC       = mpif90 -c -fbacktrace -fbounds-check 
+#-O -Wuninitialized "-ffpe-trap=invalid,zero,overflow"  -fbacktrace -g
+LD       = mpif90
+DEBUG    =
+FCFLAGS  = -DPARALLEL -O2 -pedantic -fexternal-blas $(DEBUG)
+LDFLAGS  = -static-libgfortran $(DEBUG)
+NUMLIB   = -framework Accelerate
+# -Wl,--start-group \
+           $(MKLROOT)/lib/intel64/libmkl_intel_lp64.a \
+           $(MKLROOT)/lib/intel64/libmkl_core.a \
+           $(MKLROOT)/lib/intel64/libmkl_sequential.a \
+           -Wl,--end-group -lpthread -lm -ldl
+
+CC       = gcc -c
+CCFLAGS  =
+
+# linker for C-interoperable library (gcc & gfortran)
+LIBLD    = gcc
+LIBFLAGS = -shared
+LIBLIB   = -lgfortran
+
+AR       = ar
+ARFLAGS  = -crusv
+
+include ./Makefile.inc
diff -Naru src/makefiles/Makefile.ifort_mpi src_modified/makefiles/Makefile.ifort_mpi
--- src/makefiles/Makefile.ifort_mpi	2025-04-08 11:32:06.108110077 +0900
+++ src_modified/makefiles/Makefile.ifort_mpi	2025-04-08 13:27:27.572785785 +0900
@@ -26,18 +26,22 @@
 DEBUG    = # -g -warn all -check bounds
 FCFLAGS  = -DPARALLEL -O2 $(DEBUG)
 LDFLAGS  = -static-intel $(DEBUG)
-NUMLIB   = -Wl,--start-group \
-           $(MKLROOT)/lib/intel64/libmkl_intel_lp64.a \
-           $(MKLROOT)/lib/intel64/libmkl_core.a \
-           $(MKLROOT)/lib/intel64/libmkl_sequential.a \
-           -Wl,--end-group -lpthread -lm
+NUMLIB = -mkl=sequential
+#NUMLIB   = -Wl,--start-group \
+#           $(MKLROOT)/lib/intel64/libmkl_intel_lp64.a \
+#           $(MKLROOT)/lib/intel64/libmkl_core.a \
+ #          $(MKLROOT)/lib/intel64/libmkl_sequential.a \
+#           -Wl,--end-group -lpthread -lm
 
+#CC       = icc -c
 CC       = gcc -c
 CCFLAGS  =
 
 # linker for C-interoperable library (gcc & gfortran)
+#LIBLD    = icc
 LIBLD    = gcc
 LIBFLAGS = -shared
+#LIBLIB   = 
 LIBLIB   = -lgfortran
 
 AR       = ar
diff -Naru src/parallel.F90 src_modified/parallel.F90
--- src/parallel.F90	2025-04-08 11:32:06.106110012 +0900
+++ src_modified/parallel.F90	2025-04-08 13:27:27.573785811 +0900
@@ -18,7 +18,7 @@
 ! This module mainly provides generic interfaces to the FORTRAN 77 MPI
 ! bindings.  The MPI send, receive and broadcast operations are
 ! simplified for the case of a rank 0 master process and the single
-! communicator MPI_COMM_WORLD.
+! communicator mpi_comm_aenet.
 !
 ! The prodedures for sending and receiving derived types defined in
 ! this module only send primitive data types.  This is probably not
@@ -28,8 +28,19 @@
 ! 2011-11-10 Alexander Urban (AU), Nongnuch Artrith (NA)
 !-----------------------------------------------------------------------
 
+module aenet_mpimodule
+!  use common_variables, only : mpi_comm_aenet_sub, myrank_sub, nprocs_sub
+  implicit none
+  include 'mpif.h'
+  save
+  integer, public :: mpi_comm_aenet = mpi_comm_world
+end module aenet_mpimodule
+
+
+
 
 module parallel
+  
 
   use aeio,        only: aeio_header
 
@@ -47,6 +58,7 @@
 
   use trainset,    only: TrnSet,      &
                          new_TrnSet_info
+  use aenet_mpimodule,only:mpi_comm_aenet
 
   implicit none
   save
@@ -81,7 +93,8 @@
             pp_bcast_NNPot,       &
             pp_bcast_coo,         &
             pp_bcast_latt,        &
-            pp_sum_weights
+            pp_sum_weights, &
+            set_isinit_false
 
   !------------------------------ public ------------------------------!
 
@@ -191,9 +204,20 @@
                       pp_sum_dn
   end interface
 
+  !--------------------------------------------------------------------!
+  !           training set file footer containing statistics           !
+  !--------------------------------------------------------------------!
+
+
+
 
 contains !=============================================================!
 
+  subroutine set_isinit_false()
+    implicit none
+    isInit = .false.
+    return
+  end subroutine set_isinit_false
 
   subroutine pp_init()
 
@@ -202,10 +226,10 @@
     if (isInit) return
 
 #ifdef PARALLEL
-    call MPI_Init(ierr)
+!    call MPI_Init(ierr)
 
-    call MPI_Comm_size(MPI_COMM_WORLD, ppSize, ierr)
-    call MPI_Comm_rank(MPI_COMM_WORLD, ppRank, ierr)
+    call mpi_comm_size(mpi_comm_aenet, ppSize, ierr)
+    call mpi_comm_rank(mpi_comm_aenet, ppRank, ierr)
 
     isParallel = .true.
 #endif
@@ -220,6 +244,86 @@
 
   end subroutine pp_init
 
+
+  subroutine pp_calc_and_Bcast_footer(ts, stp)
+
+    implicit none
+
+    type(TrnSet),intent(inout) :: ts
+    type(Setup), dimension(:), intent(inout) :: stp
+
+    real(8) :: E_max, E_min, E_av, E_avsum, E_avsum_sum,Etemp
+    integer :: nAtomsTot, nStrucs,ntemp
+    integer :: ierr, itype
+    integer :: neval,itemp
+    real(8), dimension(:), allocatable :: d2
+
+!   calculate max, min, average
+    E_avsum = ts%E_av * dble(ts%nStrucs)
+
+    call MPI_ALLREDUCE( ts%nAtomsTot, nAtomsTot, 1, MPI_INTEGER, MPI_SUM, mpi_comm_aenet, ierr )
+    Etemp = ts%E_max
+    call pp_bcast(Etemp)
+    ts%E_max = max(ts%E_max,Etemp)
+
+    call MPI_ALLREDUCE( ts%E_max, E_max, 1, MPI_DOUBLE_PRECISION, MPI_MAX, mpi_comm_aenet, ierr )
+    
+    Etemp = ts%E_min
+    call pp_bcast(Etemp)
+    ts%E_min = min(ts%E_min,Etemp)
+
+    call MPI_ALLREDUCE( ts%E_min, E_min, 1, MPI_DOUBLE_PRECISION, MPI_MIN, mpi_comm_aenet, ierr )
+    
+    call MPI_ALLREDUCE( E_avsum, E_avsum_sum, 1, MPI_DOUBLE_PRECISION, MPI_SUM, mpi_comm_aenet, ierr )
+
+    itemp = ts%iStruc
+    call MPI_ALLREDUCE( itemp, nStrucs, 1, MPI_INTEGER, MPI_SUM, mpi_comm_aenet, ierr )
+
+    ts%nAtomsTot = nAtomsTot
+    ts%E_max = E_max
+    ts%E_min = E_min
+    ts%nStrucs = nStrucs
+    ts%iStruc = nStrucs
+    ts%E_av = E_avsum_sum / dble(ts%nStrucs)
+
+
+    if (ts%iStruc < ts%nStrucs) then
+       write(0,*) "Warning: writing footer to incomplete training set file."
+    end if
+
+    do itype = 1, ubound(stp,1)
+       stp(itype)%neval= max( stp(itype)%neval,0)
+       call MPI_ALLREDUCE( stp(itype)%neval, neval, 1, MPI_INTEGER, MPI_SUM, mpi_comm_aenet, ierr )
+
+       allocate(d2(1:ubound(stp(itype)%sfval_min,1)))
+       call MPI_ALLREDUCE( stp(itype)%sfval_min, d2, ubound(d2,1), MPI_DOUBLE_PRECISION, MPI_MIN, mpi_comm_aenet, ierr )
+       stp(itype)%sfval_min = d2
+       deallocate(d2)
+       allocate(d2(1:ubound(stp(itype)%sfval_max,1)))
+       call MPI_ALLREDUCE( stp(itype)%sfval_max, d2, ubound(d2,1), MPI_DOUBLE_PRECISION, MPI_MAX, mpi_comm_aenet, ierr )
+       stp(itype)%sfval_max = d2
+       deallocate(d2)
+       allocate(d2(1:ubound(stp(itype)%sfval_avg,1)))
+       call MPI_ALLREDUCE( stp(itype)%sfval_avg*stp(itype)%neval, &
+          d2, ubound(d2,1), MPI_DOUBLE_PRECISION, MPI_SUM, mpi_comm_aenet, ierr )
+       stp(itype)%sfval_avg = d2 / neval
+       deallocate(d2)
+       allocate(d2(1:ubound(stp(itype)%sfval_cov,1)))
+       call MPI_ALLREDUCE( stp(itype)%sfval_cov*stp(itype)%neval, &
+          d2, ubound(d2,1), MPI_DOUBLE_PRECISION, MPI_SUM, mpi_comm_aenet, ierr )
+       stp(itype)%sfval_cov = d2 / neval
+       deallocate(d2)
+
+       stp(itype)%neval = neval
+
+!       write(*,*) 'CHECK', itype, stp(itype)%neval, &
+!       stp(itype)%sfval_min(1), stp(itype)%sfval_max(1), stp(itype)%sfval_avg(1), &
+!       stp(itype)%sfval_cov(1)
+
+    end do
+
+  end subroutine pp_calc_and_Bcast_footer    
+
   !--------------------------------------------------------------------!
 
   subroutine pp_final()
@@ -229,7 +333,7 @@
     if (.not. isInit) return
 
 #ifdef PARALLEL
-    call MPI_Finalize(ierr)
+!    call MPI_Finalize(ierr)
 #endif
 
     isInit     = .false.
@@ -384,6 +488,9 @@
     call pp_send(stp%sfval_avg(1:stp%nsf), stp%nsf, dest)
     call pp_send(stp%sfval_cov(1:stp%nsf), stp%nsf, dest)
 
+    call pp_send(stp%init, dest)!added
+    call pp_send(stp%description, dest)!added
+
   end subroutine pp_send_Setup
 
   !--------------------------------------------------------------------!
@@ -424,6 +531,9 @@
     call pp_recv(stp%sfval_avg(1:stp%nsf), nsf)
     call pp_recv(stp%sfval_cov(1:stp%nsf), nsf)
 
+    call pp_recv(stp%init)!added
+    call pp_recv(stp%description)!added
+
   end function pp_recv_Setup
 
   !--------------------------------------------------------------------!
@@ -716,6 +826,12 @@
 
     call pp_send(inp%mc_relax_final, dest)
 
+    call pp_send(inp%print_atomic_energies, dest)
+
+    call pp_send(inp%file, dest) !added
+    call pp_send(inp%outFileName, dest) !added
+    call pp_send(inp%verbosity, dest) !added    
+
   end subroutine pp_send_InputData
 
   !--------------------------------------------------------------------!
@@ -826,6 +942,13 @@
 
     call pp_recv(inp%mc_relax_final)
 
+    call pp_recv(inp%print_atomic_energies)
+
+    call pp_recv(inp%file) !added
+    call pp_recv(inp%outFileName) !added
+
+    call pp_recv(inp%verbosity) !added    
+
   end function pp_recv_InputData
 
   !--------------------------------------------------------------------!
@@ -949,7 +1072,7 @@
     if (.not. isParallel) return
 
 #ifdef PARALLEL
-    call MPI_Barrier(MPI_COMM_WORLD, ierr)
+    call MPI_Barrier(mpi_comm_aenet, ierr)
 #endif
 
   end subroutine pp_barrier
@@ -975,9 +1098,9 @@
 
 #ifdef PARALLEL
     if (present(root)) then
-       call MPI_Bcast(val, 1, MPI_INTEGER, root, MPI_COMM_WORLD, ierr)
+       call MPI_Bcast(val, 1, MPI_INTEGER, root, mpi_comm_aenet, ierr)
     else
-       call MPI_Bcast(val, 1, MPI_INTEGER, 0,    MPI_COMM_WORLD, ierr)
+       call MPI_Bcast(val, 1, MPI_INTEGER, 0,    mpi_comm_aenet, ierr)
     end if
 #else
     write(*,*) val, root
@@ -999,9 +1122,9 @@
 
 #ifdef PARALLEL
     if (present(root)) then
-       call MPI_Bcast(val, n, MPI_INTEGER, root, MPI_COMM_WORLD, ierr)
+       call MPI_Bcast(val, n, MPI_INTEGER, root, mpi_comm_aenet, ierr)
     else
-       call MPI_Bcast(val, n, MPI_INTEGER, 0,    MPI_COMM_WORLD, ierr)
+       call MPI_Bcast(val, n, MPI_INTEGER, 0,    mpi_comm_aenet, ierr)
     end if
 #else
     write(*,*) n, val, root
@@ -1022,9 +1145,9 @@
 
 #ifdef PARALLEL
     if (present(root)) then
-       call MPI_Bcast(val, 1, MPI_DOUBLE_PRECISION, root, MPI_COMM_WORLD, ierr)
+       call MPI_Bcast(val, 1, MPI_DOUBLE_PRECISION, root, mpi_comm_aenet, ierr)
     else
-       call MPI_Bcast(val, 1, MPI_DOUBLE_PRECISION, 0,    MPI_COMM_WORLD, ierr)
+       call MPI_Bcast(val, 1, MPI_DOUBLE_PRECISION, 0,    mpi_comm_aenet, ierr)
     end if
 #else
     write(*,*) val, root
@@ -1046,9 +1169,9 @@
 
 #ifdef PARALLEL
     if (present(root)) then
-       call MPI_Bcast(val, n, MPI_DOUBLE_PRECISION, root, MPI_COMM_WORLD, ierr)
+       call MPI_Bcast(val, n, MPI_DOUBLE_PRECISION, root, mpi_comm_aenet, ierr)
     else
-       call MPI_Bcast(val, n, MPI_DOUBLE_PRECISION, 0,    MPI_COMM_WORLD, ierr)
+       call MPI_Bcast(val, n, MPI_DOUBLE_PRECISION, 0,    mpi_comm_aenet, ierr)
     end if
 #else
     write(*,*) n, val, root
@@ -1069,9 +1192,9 @@
 
 #ifdef PARALLEL
     if (present(root)) then
-       call MPI_Bcast(val, 1, MPI_LOGICAL, root, MPI_COMM_WORLD, ierr)
+       call MPI_Bcast(val, 1, MPI_LOGICAL, root, mpi_comm_aenet, ierr)
     else
-       call MPI_Bcast(val, 1, MPI_LOGICAL, 0,    MPI_COMM_WORLD, ierr)
+       call MPI_Bcast(val, 1, MPI_LOGICAL, 0,    mpi_comm_aenet, ierr)
     end if
 #else
     write(*,*) val, root
@@ -1093,9 +1216,9 @@
 
 #ifdef PARALLEL
     if (present(root)) then
-       call MPI_Bcast(val, n, MPI_LOGICAL, root, MPI_COMM_WORLD, ierr)
+       call MPI_Bcast(val, n, MPI_LOGICAL, root, mpi_comm_aenet, ierr)
     else
-       call MPI_Bcast(val, n, MPI_LOGICAL, 0,    MPI_COMM_WORLD, ierr)
+       call MPI_Bcast(val, n, MPI_LOGICAL, 0,    mpi_comm_aenet, ierr)
     end if
 #else
     write(*,*) n, val, root
@@ -1120,9 +1243,9 @@
 
 #ifdef PARALLEL
     if (present(root)) then
-       call MPI_Bcast(val, n, MPI_CHARACTER, root, MPI_COMM_WORLD, ierr)
+       call MPI_Bcast(val, n, MPI_CHARACTER, root, mpi_comm_aenet, ierr)
     else
-       call MPI_Bcast(val, n, MPI_CHARACTER, 0,    MPI_COMM_WORLD, ierr)
+       call MPI_Bcast(val, n, MPI_CHARACTER, 0,    mpi_comm_aenet, ierr)
     end if
 #else
     n = root
@@ -1149,9 +1272,9 @@
 
 #ifdef PARALLEL
     if (present(root)) then
-       call MPI_Bcast(val, m, MPI_CHARACTER, root, MPI_COMM_WORLD, ierr)
+       call MPI_Bcast(val, m, MPI_CHARACTER, root, mpi_comm_aenet, ierr)
     else
-       call MPI_Bcast(val, m, MPI_CHARACTER, 0,    MPI_COMM_WORLD, ierr)
+       call MPI_Bcast(val, m, MPI_CHARACTER, 0,    mpi_comm_aenet, ierr)
     end if
 #else
     write(*,*) n, val, root
@@ -1182,7 +1305,7 @@
     if (.not. isParallel) return
 
 #ifdef PARALLEL
-    call MPI_Send(val, 1, MPI_INTEGER, dest, tag, MPI_COMM_WORLD, ierr)
+    call MPI_Send(val, 1, MPI_INTEGER, dest, tag, mpi_comm_aenet, ierr)
 #else
     write(*,*) val, dest
 #endif
@@ -1204,7 +1327,7 @@
     if (.not. isParallel) return
 
 #ifdef PARALLEL
-    call MPI_Send(val, n, MPI_INTEGER, dest, tag, MPI_COMM_WORLD, ierr)
+    call MPI_Send(val, n, MPI_INTEGER, dest, tag, mpi_comm_aenet, ierr)
 #else
     write(*,*) n, val, dest
 #endif
@@ -1225,7 +1348,7 @@
     if (.not. isParallel) return
 
 #ifdef PARALLEL
-    call MPI_Send(val, 1, MPI_DOUBLE_PRECISION, dest, tag, MPI_COMM_WORLD, ierr)
+    call MPI_Send(val, 1, MPI_DOUBLE_PRECISION, dest, tag, mpi_comm_aenet, ierr)
 #else
     write(*,*) val, dest
 #endif
@@ -1247,7 +1370,7 @@
     if (.not. isParallel) return
 
 #ifdef PARALLEL
-    call MPI_Send(val, n, MPI_DOUBLE_PRECISION, dest, tag, MPI_COMM_WORLD, ierr)
+    call MPI_Send(val, n, MPI_DOUBLE_PRECISION, dest, tag, mpi_comm_aenet, ierr)
 #else
     write(*,*) n, val, dest
 #endif
@@ -1268,7 +1391,7 @@
     if (.not. isParallel) return
 
 #ifdef PARALLEL
-    call MPI_Send(val, 1, MPI_LOGICAL, dest, tag, MPI_COMM_WORLD, ierr)
+    call MPI_Send(val, 1, MPI_LOGICAL, dest, tag, mpi_comm_aenet, ierr)
 #else
     write(*,*) val, dest
 #endif
@@ -1292,7 +1415,7 @@
 
 #ifdef PARALLEL
     n = len(val)
-    call MPI_Send(val, n, MPI_CHARACTER, dest, tag, MPI_COMM_WORLD, ierr)
+    call MPI_Send(val, n, MPI_CHARACTER, dest, tag, mpi_comm_aenet, ierr)
 #else
     n = dest
     write(*,*) val
@@ -1318,7 +1441,7 @@
 
 #ifdef PARALLEL
     m = len(val(1))
-    call MPI_Send(val, m*n, MPI_CHARACTER, dest, tag, MPI_COMM_WORLD, ierr)
+    call MPI_Send(val, m*n, MPI_CHARACTER, dest, tag, mpi_comm_aenet, ierr)
 #else
     m = n*dest
     write(*,*) val
@@ -1350,10 +1473,10 @@
 #ifdef PARALLEL
     if (present(src)) then
        call MPI_Recv(val, 1, MPI_INTEGER, src, tag,       &
-                     MPI_COMM_WORLD, status, ierr)
+                     mpi_comm_aenet, status, ierr)
     else
        call MPI_Recv(val, 1, MPI_INTEGER, MPI_ANY_SOURCE, &
-                     tag, MPI_COMM_WORLD, status, ierr)
+                     tag, mpi_comm_aenet, status, ierr)
     end if
 #else
     val = src
@@ -1378,10 +1501,10 @@
 #ifdef PARALLEL
     if (present(src)) then
        call MPI_Recv(val, n, MPI_INTEGER, src, tag,       &
-                     MPI_COMM_WORLD, status, ierr)
+                     mpi_comm_aenet, status, ierr)
     else
        call MPI_Recv(val, n, MPI_INTEGER, MPI_ANY_SOURCE, &
-                     tag, MPI_COMM_WORLD, status, ierr)
+                     tag, mpi_comm_aenet, status, ierr)
     end if
 #else
     val = n*src
@@ -1405,10 +1528,10 @@
 #ifdef PARALLEL
     if (present(src)) then
        call MPI_Recv(val, 1, MPI_DOUBLE_PRECISION, src, tag,       &
-                     MPI_COMM_WORLD, status, ierr)
+                     mpi_comm_aenet, status, ierr)
     else
        call MPI_Recv(val, 1, MPI_DOUBLE_PRECISION, MPI_ANY_SOURCE, &
-                     tag, MPI_COMM_WORLD, status, ierr)
+                     tag, mpi_comm_aenet, status, ierr)
     end if
 #else
     val = 1.0*src
@@ -1433,10 +1556,10 @@
 #ifdef PARALLEL
     if (present(src)) then
        call MPI_Recv(val, n, MPI_DOUBLE_PRECISION, src, tag,       &
-                     MPI_COMM_WORLD, status, ierr)
+                     mpi_comm_aenet, status, ierr)
     else
        call MPI_Recv(val, n, MPI_DOUBLE_PRECISION, MPI_ANY_SOURCE, &
-                     tag, MPI_COMM_WORLD, status, ierr)
+                     tag, mpi_comm_aenet, status, ierr)
     end if
 #else
     val = 1.0d0*n*src
@@ -1460,10 +1583,10 @@
 #ifdef PARALLEL
     if (present(src)) then
        call MPI_Recv(val, 1, MPI_LOGICAL, src, tag,       &
-                     MPI_COMM_WORLD, status, ierr)
+                     mpi_comm_aenet, status, ierr)
     else
        call MPI_Recv(val, 1, MPI_LOGICAL, MPI_ANY_SOURCE, &
-                     tag, MPI_COMM_WORLD, status, ierr)
+                     tag, mpi_comm_aenet, status, ierr)
     end if
 #else
     val = (src == 1)
@@ -1490,10 +1613,10 @@
     n = len(val)
     if (present(src)) then
        call MPI_Recv(val, n, MPI_CHARACTER, src, tag,       &
-                     MPI_COMM_WORLD, status, ierr)
+                     mpi_comm_aenet, status, ierr)
     else
        call MPI_Recv(val, n, MPI_CHARACTER, MPI_ANY_SOURCE, &
-                     tag, MPI_COMM_WORLD, status, ierr)
+                     tag, mpi_comm_aenet, status, ierr)
     end if
 #else
     n = src
@@ -1522,10 +1645,10 @@
     m = len(val(1))
     if (present(src)) then
        call MPI_Recv(val, n*m, MPI_CHARACTER, src, tag,       &
-                     MPI_COMM_WORLD, status, ierr)
+                     mpi_comm_aenet, status, ierr)
     else
        call MPI_Recv(val, n*m, MPI_CHARACTER, MPI_ANY_SOURCE, &
-                     tag, MPI_COMM_WORLD, status, ierr)
+                     tag, mpi_comm_aenet, status, ierr)
     end if
 #else
     m = src
@@ -1555,7 +1678,7 @@
     buff = val
 #ifdef PARALLEL
     call MPI_allreduce(buff, val, 1, MPI_INTEGER, MPI_SUM, &
-                       MPI_COMM_WORLD, ierr)
+                       mpi_comm_aenet, ierr)
 #endif
 
   end subroutine pp_sum_i1
@@ -1575,7 +1698,7 @@
     buff(1:n) = val(1:n)
 #ifdef PARALLEL
     call MPI_allreduce(buff, val, n, MPI_INTEGER, MPI_SUM, &
-                       MPI_COMM_WORLD, ierr)
+                       mpi_comm_aenet, ierr)
 #endif
 
   end subroutine pp_sum_in
@@ -1594,7 +1717,7 @@
     buff = val
 #ifdef PARALLEL
     call MPI_allreduce(buff, val, 1, MPI_DOUBLE_PRECISION, MPI_SUM, &
-                       MPI_COMM_WORLD, ierr)
+                       mpi_comm_aenet, ierr)
 #endif
 
   end subroutine pp_sum_d1
@@ -1614,10 +1737,24 @@
     buff(1:n) = val(1:n)
 #ifdef PARALLEL
     call MPI_allreduce(buff, val, n, MPI_DOUBLE_PRECISION, MPI_SUM, &
-                       MPI_COMM_WORLD, ierr)
+                       mpi_comm_aenet, ierr)
 #endif
 
   end subroutine pp_sum_dn
 
 
 end module parallel
+
+
+
+
+subroutine set_mpi_aenet(mpi_comm)
+  use aenet_mpimodule
+  use parallel,only:set_isinit_false
+  integer,intent(in)::mpi_comm
+  integer::ierr
+  call set_isinit_false()
+  call mpi_comm_dup(mpi_comm,mpi_comm_aenet,ierr)
+!  mpi_comm_aenet = mpi_comm
+  return
+end subroutine set_mpi_aenet
\ No newline at end of file
diff -Naru src/predict.F90 src_modified/predict.F90
--- src/predict.F90	2025-04-08 11:32:06.106110012 +0900
+++ src_modified/predict.F90	2025-04-08 13:27:27.573785811 +0900
@@ -106,6 +106,7 @@
 
   double precision                              :: Ecoh, Etot, E0
   double precision, dimension(:,:), allocatable :: forCart
+  double precision, dimension(:,:), allocatable :: stress
   double precision, dimension(:),   allocatable :: atomicEnergy
 
   double precision, dimension(3)                :: F_mav, F_max, F_avg
@@ -177,6 +178,7 @@
      end if
      if (inp%do_forces) then
         allocate(forCart(3,nAtoms))
+        allocate(stress(3,3))
      end if
      if (inp%print_atomic_energies) then
         allocate(atomicEnergy(nAtoms))
@@ -192,10 +194,10 @@
      ! evaluate atomic energy and forces
      if (inp%do_forces .and. inp%print_atomic_energies) then
         call get_energy(latticeVec, nAtoms, cooLatt, atomType, pbc, &
-                        Ecoh, Etot, forCart=forCart, atomicEnergy=atomicEnergy)
+                        Ecoh, Etot, forCart=forCart, atomicEnergy=atomicEnergy, stress=stress)
      else if (inp%do_forces) then
         call get_energy(latticeVec, nAtoms, cooLatt, atomType, pbc, &
-                        Ecoh, Etot, forCart=forCart)
+                        Ecoh, Etot, forCart=forCart, stress=stress)
      else if (inp%print_atomic_energies) then
         call get_energy(latticeVec, nAtoms, cooLatt, atomType, pbc, &
                         Ecoh, Etot, atomicEnergy=atomicEnergy)
@@ -208,11 +210,11 @@
         if (inp%do_forces .and. inp%print_atomic_energies) then
            call print_coordinates(iter, latticeVec, nAtoms, nTypes, cooLatt, &
                                   atomType_orig, atomTypeName, origin, &
-                                  forCart=forCart, atomicEnergy=atomicEnergy)
+                                  forCart=forCart, atomicEnergy=atomicEnergy, stress=stress)
         else if (inp%do_forces) then
            call print_coordinates(iter, latticeVec, nAtoms, nTypes, cooLatt, &
                                   atomType_orig, atomTypeName, origin, &
-                                  forCart=forCart)
+                                  forCart=forCart, stress=stress)
         else if (inp%print_atomic_energies) then
            call print_coordinates(iter, latticeVec, nAtoms, nTypes, cooLatt, &
                                   atomType_orig, atomTypeName, origin, &
@@ -291,6 +293,7 @@
      end if
      if (inp%do_forces) then
         deallocate(forCart)
+        deallocate(stress)
      end if
      if (inp%print_atomic_energies) then
         deallocate(atomicEnergy)
@@ -458,7 +461,7 @@
 
   subroutine print_coordinates(iter, latticeVec, nAtoms, nTypes, cooLatt, &
                                atomType, atomTypeName, origin, forCart, &
-                               atomicEnergy)
+                               atomicEnergy, stress)
 
     implicit none
 
@@ -472,6 +475,7 @@
     double precision, dimension(3),                  intent(in) :: origin
     double precision, dimension(3,nAtoms), optional, intent(in) :: forCart
     double precision, dimension(nAtoms),   optional, intent(in) :: atomicEnergy
+    double precision, dimension(3,3), optional, intent(in)      :: stress
 
     character(len=80)              :: header
     integer                        :: iat
@@ -529,6 +533,14 @@
     end do
     write(*,*)
 
+    if (present(stress)) then
+       write(*,*) 'Stress tensor kbar         :'
+       do iat = 1, 3
+          write(*,'(3(2x,F12.6))') stress(1:3,iat)
+       end do
+    end if
+    
+
   end subroutine print_coordinates
 
   !--------------------------------------------------------------------!
@@ -565,7 +577,7 @@
   !--------------------------------------------------------------------!
 
   subroutine get_energy(latticeVec, nAtoms, cooLatt, atomType, &
-                        pbc, Ecoh, Etot, forCart, atomicEnergy)
+                        pbc, Ecoh, Etot, forCart, atomicEnergy, stress)
 
     implicit none
 
@@ -578,6 +590,9 @@
     double precision,                                intent(out) :: Etot
     double precision, dimension(3,nAtoms), optional, intent(out) :: forCart
     double precision, dimension(nAtoms),   optional, intent(out) :: atomicEnergy
+    double precision, dimension(3,3), optional, intent(out) :: stress
+    double precision, dimension(3) :: tmp_vec
+    double precision :: vol
 
 #ifdef CHECK_FORCES
     double precision, dimension(3,nAtoms) :: forCart_num
@@ -587,7 +602,7 @@
     integer :: i, j
 #endif
 
-    logical                                       :: do_F, do_E_atom
+    logical                                       :: do_F, do_E_atom, do_S
 
     integer                                       :: nnb
     integer,          dimension(aenet_nnb_max)    :: nblist
@@ -599,12 +614,14 @@
     double precision, dimension(3)                :: coo_i
     double precision                              :: E_i
 
-    integer                                       :: iatom, stat
+    integer                                       :: iatom, stat,x1,x2
 
     do_F = present(forCart)
     do_E_atom = present(atomicEnergy)
+    do_S = present(stress)
     if (do_F) forCart(1:3,1:nAtoms) = 0.0d0
     if (do_E_atom) atomicEnergy(1:nAtoms) = 0.0d0
+    if (do_S) stress(1:3,1:3) = 0.0d0
 
     call lcl_init(aenet_Rc_min, aenet_Rc_max, latticeVec, nAtoms, &
                   atomType, cooLatt, pbc)
@@ -635,7 +652,7 @@
        if (do_F) then
           call aenet_atomic_energy_and_forces( &
                coo_i, type_i, iatom, nnb, nbcoo, nbtype, nblist, &
-               nAtoms, E_i, forCart, stat)
+               nAtoms, E_i, forCart, stress, stat)
 #ifdef CHECK_FORCES
           do i = 1, 3
              coo_i = coo_i - dd(:,i)
@@ -671,6 +688,10 @@
 
     end do atoms
 
+    if (do_S) then
+
+    end if
+
 #ifdef CHECK_FORCES
     open(99, file='CHECK_FORCES.dat', status='replace', action='write')
     do iatom = 1, nAtoms
@@ -685,7 +706,6 @@
 
     call pp_sum(Ecoh)
     call pp_sum(Etot)
-
     ! gather results from all processes
     if (do_F) then
        if (ppSize>1) then
@@ -694,6 +714,28 @@
           end do
        end if
     end if
+    !stress[kbar]
+    if (do_S) then
+       if (ppSize>1) then
+          do x1 = 1,3
+             call pp_sum(stress(1:3,x1), 3)
+          end do
+       end if
+       tmp_vec(1)=latticeVec(2,1)*latticeVec(3,2)-latticeVec(3,1)*latticeVec(2,2)
+       tmp_vec(2)=latticeVec(3,1)*latticeVec(1,2)-latticeVec(1,1)*latticeVec(3,2)
+       tmp_vec(3)=latticeVec(1,1)*latticeVec(2,2)-latticeVec(2,1)*latticeVec(1,2)
+       vol=0.0d0
+       do x1 = 1, 3
+          vol = vol + latticeVec(x1,3)* tmp_vec(x1)
+       end do
+       do x1 = 1,3
+          do x2 = x1,3
+             stress(x2,x1)=stress(x2,x1)/vol*1.d3*1.6021774232052327
+             stress(x1,x2)=stress(x2,x1)
+          end do
+       end do
+    end if
+
     if (do_E_atom) call pp_sum(atomicEnergy(1:nAtoms), nAtoms)
 
   end subroutine get_energy
diff -Naru src/sfsetup.f90 src_modified/sfsetup.f90
--- src/sfsetup.f90	2025-04-08 11:32:06.108110077 +0900
+++ src_modified/sfsetup.f90	2025-04-08 13:27:27.573785811 +0900
@@ -745,6 +745,7 @@
        end do global
     end do
 
+    stp%ntypes_global = ntypes_global !added by YN
   end subroutine stp_set_global_types
 
 
@@ -774,8 +775,10 @@
     integer            :: nG_max
 
     if (isInit) then
-       write(0,*) "Error: module already initialized in `stp_init'."
-       stop
+       return
+       !call stp_final(ntypes, stp)
+       !write(0,*) "Error: module already initialized in `stp_init'."
+       !stop
     end if
 
     sftype = trim(stp(1)%sftype)
diff -Naru src/trainset.f90 src_modified/trainset.f90
--- src/trainset.f90	2025-04-08 11:32:06.108110077 +0900
+++ src_modified/trainset.f90	2025-04-08 13:52:05.919934281 +0900
@@ -291,8 +291,11 @@
     call ts_assert_init(ts)
     call ts_assert_readmode(ts)
 
-    if (present(rec) .and. (rec > 0)) then
+    !if (present(rec) .and. (rec > 0)) then
+    if (present(rec)) then
+      if (rec > 0) then
        irec = rec - 1
+      end if
     else
        irec = 0
     end if
@@ -1187,10 +1190,8 @@
     write(*,*)
 
     allocate(stp(ts%nTypes))
-
     call ts_read_footer(ts, stp=stp)
     call rewind_TrnSet(ts)
-
     !$ ! initialize the setup module to allocate needed memory
     !$ ! however, we set nnb_max=1, as more is not necessary
     !$ call stp_init(ts%nTypes, stp, 1)
@@ -1204,7 +1205,7 @@
     write(*,*) '  Energy scaling factor: f = ' // trim(io_adjustl(scale,6))
     write(*,*) '  Atomic energy shift  : s = ' // trim(io_adjustl(shift,6))
     write(*,*)
-
+ 
     ! If maxenergy is lower than some structure in the initial training
     ! set, these structures will not be included.  Thus, we need to count
     ! all included structures.
@@ -1226,6 +1227,8 @@
        nStrucs2 = ts%nStrucs
     end if
 
+   
+
     ! new normalized (and possibly smaller) training set
     ts2 = new_TrnSet(ts%nTypes, ts%typeName, ts%E_atom, nStrucs2, &
                      trim(file2), scale=scale, shift=shift)
diff -Naru src/trainset_MPI.f90 src_modified/trainset_MPI.f90
--- src/trainset_MPI.f90	1970-01-01 09:00:00.000000000 +0900
+++ src_modified/trainset_MPI.f90	2025-04-08 13:27:27.573785811 +0900
@@ -0,0 +1,543 @@
+!-----------------------------------------------------------------------
+!           trainset.f90 - handling of the training set file
+!-----------------------------------------------------------------------
+!+ This file is part of the AENET package.
+!+
+!+ Copyright (C) 2012-2018 Nongnuch Artrith and Alexander Urban
+!+
+!+ This Source Code Form is subject to the terms of the Mozilla Public
+!+ License, v. 2.0. If a copy of the MPL was not distributed with this
+!+ file, You can obtain one at http://mozilla.org/MPL/2.0/.
+!+
+!+ This program is distributed in the hope that it will be useful, but
+!+ WITHOUT ANY WARRANTY; without even the implied warranty of
+!+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+!+ Mozilla Public License, v. 2.0, for more details.
+!-----------------------------------------------------------------------
+! 2013-05-09 Alexander Urban (AU), Nongnuch Artrith (NA)
+!-----------------------------------------------------------------------
+
+module trainset_MPI
+
+  use aeio,    only: aeio_header,           &
+                     TYPELEN, PATHLEN
+
+  use io,      only: io_adjustl,            &
+                     io_unit
+
+  use sfsetup, only: Setup,                 &
+                     save_Setup,            &
+                     load_Setup,            &
+                     del_Setup,             &
+                     stp_init,              &
+                     stp_final,             &
+                     stp_normalize,         &
+                     stp_assert_moduleinit, &
+                     stp_nsf_max
+
+  use trainset, only: TrnSet
+
+  use parallel,    only: pp_init,                &
+                         pp_final,               &
+                         pp_bcast,               &
+                         pp_barrier,             &
+                         ppMaster,               &
+                         ppRank,                 &
+                         ppSize,&
+                         pp_calc_and_bcast_footer
+
+  implicit none
+  private
+  save
+
+  public  :: new_TrnSet_MPI,          &
+             close_TrnSet_MPI,        &
+             save_TrnSet_info_MPI,    &
+             ts_write_atom_info_MPI,  &
+             ts_write_header_MPI,     &
+             ts_write_sf_info_MPI,    &
+             ts_write_structure_info_MPI, &
+             ts_write_footer_MPI,     &
+             ts_parallel_footer_MPI,   &
+             ts_loadandwrite_structure_info_MPI
+
+  private :: ts_assert_init,          &
+             ts_assert_writemode,     &
+             ts_assert_readmode
+
+  !--------------------------------------------------------------------!
+  ! Basis function values and derivatives may be read and written      !
+  ! either using a basis function setup [type(Setup)] or directly into !
+  ! double precision arrays of the correct dimensions.                 !
+  !--------------------------------------------------------------------!
+
+contains
+
+  function new_TrnSet_MPI(nTypes, typeName, E_atom, nStrucs, file, scale, &
+                      shift) result(ts)
+
+    implicit none
+
+    integer,                             intent(in) :: nTypes
+    character(len=*), dimension(nTypes), intent(in) :: typeName
+    double precision, dimension(nTypes), intent(in) :: E_atom
+    integer,                             intent(in) :: nStrucs
+    character(len=*),                    intent(in) :: file
+    double precision, optional,          intent(in) :: scale
+    double precision, optional,          intent(in) :: shift
+    type(TrnSet)                                    :: ts
+
+    logical :: fexists
+
+!    if (ppMaster) then
+!       inquire(file=trim(adjustl(file)), exist=fexists)
+!       if (fexists) then
+!          write(0,*) 'Error: file already exists: ', trim(adjustl(file))
+!          stop
+!       end if
+!    end if
+
+    allocate(ts%typeName(nTypes), ts%E_atom(nTypes))
+
+    ts%file               = trim(adjustl(file))
+    ts%nTypes             = nTypes
+    ts%typeName(1:nTypes) = typeName(1:nTypes)
+    ts%E_atom(1:nTypes)   = E_atom(1:nTypes)
+    ts%nStrucs            = nStrucs
+    ts%iStruc             = 0
+    if (present(scale) .and. present(shift)) then
+       ts%normalized = .true.
+       ts%scale = scale
+       ts%shift = shift
+    else
+       ts%normalized = .false.
+       ts%scale = 1.0d0
+       ts%shift = 0.0d0
+    end if
+
+    ts%unit   = io_unit()
+!    open(ts%unit, file=trim(ts%file), status='new', action='write', &
+!         form='unformatted')
+
+    ts%nAtomsTot = 0
+
+    ts%mode = 'write'
+    ts%init = .true.
+
+    call ts_write_header_MPI(ts)
+
+  end function new_TrnSet_MPI
+
+  !--------------------------------------------------------------------!
+
+  subroutine close_TrnSet_MPI(ts, stp, status)
+
+    implicit none
+
+    type(TrnSet),                        intent(inout) :: ts
+    type(Setup), dimension(:), optional, intent(in)    :: stp
+    character(len=*),          optional, intent(in)    :: status
+
+    if (.not. ts%init) return
+
+    if (trim(ts%mode) == 'write') then
+       if (present(stp)) then
+          call ts_write_footer_MPI(ts, stp=stp)
+       else
+          call ts_write_footer_MPI(ts)
+       end if
+    end if
+
+    if ((trim(ts%mode)=='read') .or. (trim(ts%mode)=='write')) then
+       if (present(status)) then
+          close(ts%unit, status=trim(status))
+       else
+          close(ts%unit)
+       end if
+    end if
+
+    deallocate(ts%typeName, ts%E_atom)
+    ts%init   = .false.
+
+  end subroutine close_TrnSet_MPI
+
+  !--------------------------------------------------------------------!
+  !              only training set info - no actual data               !
+  !--------------------------------------------------------------------!
+
+  subroutine save_TrnSet_info_MPI(ts, file, unit)
+
+    implicit none
+
+    type(TrnSet),               intent(in) :: ts
+    character(len=*), optional, intent(in) :: file
+    integer,          optional, intent(in) :: unit
+
+    integer :: u
+
+    call ts_assert_init(ts)
+    call ts_assert_readmode(ts)
+
+    if (present(unit)) then
+       u = unit
+    else if (present(file)) then
+       u = io_unit()
+       open(u, file=trim(file), status='replace', &
+            form='unformatted', action='write')
+    else
+       write(0,*) "Error: neither unit nor file specified in `save_TrnSet_info()'."
+       stop
+    end if
+
+    write(u) ts%file
+    write(u) ts%normalized
+    write(u) ts%scale
+    write(u) ts%shift
+    write(u) ts%nTypes
+    write(u) ts%typeName(1:ts%nTypes)
+    write(u) ts%E_atom(1:ts%nTypes)
+    write(u) ts%nAtomsTot
+    write(u) ts%nStrucs
+    write(u) ts%E_min, ts%E_max, ts%E_av
+
+    if (.not. present(unit)) close(u)
+
+  end subroutine save_TrnSet_info_MPI
+
+  !--------------------------------------------------------------------!
+
+  function new_TrnSet_info_MPI(nTypes) result(ts)
+
+    implicit none
+
+    integer,                             intent(in) :: nTypes
+    type(TrnSet)                                    :: ts
+
+    allocate(ts%typeName(nTypes), ts%E_atom(nTypes))
+
+    ts%nTypes     = nTypes
+    ts%normalized = .false.
+    ts%scale      = 1.0d0
+    ts%shift      = 1.0d0
+    ts%file       = ''
+    ts%unit       = -1
+    ts%nAtomsTot  = 0
+    ts%nStrucs    = 0
+    ts%iStruc     = 0
+
+    ts%init = .true.
+    ts%mode = 'info'
+
+  end function new_TrnSet_info_MPI
+
+  !--------------------------------------------------------------------!
+  !                      training set file header                      !
+  !--------------------------------------------------------------------!
+
+  subroutine ts_write_header_MPI(ts)
+
+    implicit none
+
+    type(TrnSet), intent(inout) :: ts
+    integer :: ts_unit = 1234
+    integer :: ts_unitall = 12345
+
+    call ts_assert_init(ts)
+    call ts_assert_writemode(ts)
+
+    if (ppMaster) then
+       open (ts_unit, file='ts.header', form='unformatted', position='append')
+       write(ts_unit) ts%nTypes
+       write(ts_unit) ts%nStrucs
+       write(ts_unit) ts%typeName(:)
+       write(ts_unit) ts%E_atom(:)
+       write(ts_unit) ts%normalized
+       write(ts_unit) ts%scale
+       write(ts_unit) ts%shift
+       close(ts_unit)
+
+       open (ts_unitall, file='ts.all', form='unformatted', status='replace')
+       write(ts_unitall) ts%nTypes
+       write(ts_unitall) ts%nStrucs
+       write(ts_unitall) ts%typeName(:)
+       write(ts_unitall) ts%E_atom(:)
+       write(ts_unitall) ts%normalized
+       write(ts_unitall) ts%scale
+       write(ts_unitall) ts%shift
+       close(ts_unitall)
+    end if
+
+  end subroutine ts_write_header_MPI
+
+  !--------------------------------------------------------------------!
+  !           training set file footer containing statistics           !
+  !--------------------------------------------------------------------!
+
+  subroutine ts_parallel_footer_MPI(ts, stp)
+
+    implicit none
+
+    type(TrnSet),                        intent(inout) :: ts
+    type(Setup), dimension(:), intent(inout) :: stp
+
+   call pp_calc_and_bcast_footer(ts,stp)
+
+  end subroutine ts_parallel_footer_MPI
+
+  subroutine ts_write_footer_MPI(ts, stp)
+
+    implicit none
+
+    type(TrnSet),                        intent(inout) :: ts
+    type(Setup), dimension(:), optional, intent(in) :: stp
+
+    integer :: itype, nTypes
+    logical :: has_setups
+    integer :: ts_unit = 1234
+    integer :: ts_unitall = 12345
+
+    call ts_assert_init(ts)
+    call ts_assert_writemode(ts)
+
+    if (ppMaster) then
+
+       open (ts_unit, file='ts.footer', form='unformatted', position='append')
+       open (ts_unitall, file='ts.all', form='unformatted', position='append')
+
+       write(ts_unit) ts%nAtomsTot
+       write(ts_unitall) ts%nAtomsTot
+       write(ts_unit) ts%E_av, ts%E_min, ts%E_max
+       write(ts_unitall) ts%E_av, ts%E_min, ts%E_max
+!       write(5678,*) ts%nAtomsTot
+!       write(5678,*) ts%E_av, ts%E_min, ts%E_max
+!
+       if (present(stp)) then
+          nTypes = size(stp(:))
+          if (nTypes /= ts%nTypes) then
+             write(0,*) "Error: wrong size of array stp in `ts_read_footer()'."
+             stop
+          end if
+          has_setups = .true.
+          write(ts_unit) has_setups
+          write(ts_unitall) has_setups
+!          write(5678,*) has_setups
+          do itype = 1, ts%nTypes
+             write(ts_unit) itype
+             write(ts_unitall) itype
+!             write(5678,*) itype
+             call save_Setup(stp(itype), unit=ts_unit)
+             call save_Setup(stp(itype), unit=ts_unitall)
+          end do
+       else
+          has_setups = .false.
+!          write(5678,*) has_setups
+          write(ts_unit) has_setups
+          write(ts_unitall) has_setups
+       end if
+
+       close(ts_unit)
+       close(ts_unitall)
+
+    end if
+
+  end subroutine ts_write_footer_MPI
+
+  subroutine ts_loadandwrite_structure_info_MPI(ifile)
+
+   implicit none
+
+   integer:: nAtoms
+   integer:: nTypes
+   double precision:: energy
+   integer,          intent(in)    :: ifile
+   integer :: ts_unit = 1234
+   integer :: ts_unitall = 12345
+   character(len=100)::filenameload
+   integer::iatom
+   integer::itype
+   double precision, dimension(3):: cooCart
+   double precision, dimension(3):: forCart
+
+   integer:: nsf
+   double precision, dimension(:),allocatable:: sfval
+
+   double precision :: E_atom
+   integer::l
+
+
+   open (ts_unitall, file='ts.all', form='unformatted', position='append')
+   open (ts_unit, file='ts.'//io_adjustl(ifile), form='unformatted', status='old')
+
+   read(ts_unit) l
+   filenameload = " "
+   l = min(l,len(filenameload))
+   read(ts_unit) filenameload(1:l)
+
+   write(ts_unitall) len_trim(filenameload)
+   write(ts_unitall) trim(filenameload)
+
+
+
+   read(ts_unit) nAtoms, nTypes
+   write(ts_unitall) nAtoms, nTypes
+
+   read(ts_unit) energy
+   write(ts_unitall) energy
+
+   atoms : do iatom = 1, nAtoms
+
+      read(ts_unit) itype
+      write(ts_unitall) itype
+
+      read(ts_unit) cooCart(1:3)
+      write(ts_unitall) cooCart(1:3)
+      read(ts_unit) forCart(1:3)
+      write(ts_unitall) forCart(1:3)
+
+      read(ts_unit) nsf
+      write(ts_unitall) nsf
+      allocate(sfval(1:nsf))
+
+      read(ts_unit) sfval(1:nsf)
+      write(ts_unitall) sfval(1:nsf)
+      deallocate(sfval)
+
+   end do atoms
+
+   close(ts_unit)
+   close(ts_unitall)
+
+
+ end subroutine ts_loadandwrite_structure_info_MPI
+
+  !--------------------------------------------------------------------!
+  !              data from structures in the training set              !
+  !--------------------------------------------------------------------!
+
+  subroutine ts_write_structure_info_MPI(ts, filename, nAtoms, nTypes, energy, ifile)
+
+    implicit none
+
+    type(TrnSet),     intent(inout) :: ts
+    character(len=*), intent(in)    :: filename
+    integer,          intent(in)    :: nAtoms
+    integer,          intent(in)    :: nTypes
+    double precision, intent(in)    :: energy
+    integer,          intent(in)    :: ifile
+    integer :: ts_unit = 1234
+
+    double precision :: E_atom
+
+    call ts_assert_init(ts)
+    call ts_assert_writemode(ts)
+
+    if (ts%iStruc >= ts%nStrucs) then
+       write(0,*) "Error: too many files for training set."
+       stop
+    else
+       ts%iStruc = ts%iStruc + 1
+    end if
+
+    open (ts_unit, file='ts.'//io_adjustl(ifile), form='unformatted', position='append')
+    write(ts_unit) len_trim(filename)
+    write(ts_unit) trim(filename)
+    write(ts_unit) nAtoms, nTypes
+    write(ts_unit) energy
+    close(ts_unit)
+
+    ! energy stats
+    E_atom = energy/dble(nAtoms)
+    if (ts%iStruc > 1) then
+       ts%E_min = min(ts%E_min, E_atom)
+       ts%E_max = max(ts%E_max, E_atom)
+       ts%E_av  = ts%E_av + E_atom/dble(ts%nStrucs)
+    else
+       ts%E_min = E_atom
+       ts%E_max = E_atom
+       ts%E_av  = E_atom/dble(ts%nStrucs)
+    end if
+
+    ! keep track of the atoms in the training set
+    ts%nAtomsTot = ts%nAtomsTot + nAtoms
+
+  end subroutine ts_write_structure_info_MPI
+
+
+  !--------------------------------------------------------------------!
+
+  subroutine ts_write_atom_info_MPI(ts, itype, cooCart, forCart, ifile)
+
+    implicit none
+
+    type(TrnSet),                   intent(inout) :: ts
+    integer,                        intent(in)    :: itype
+    double precision, dimension(3), intent(in)    :: cooCart
+    double precision, dimension(3), intent(in)    :: forCart
+    integer,          intent(in)    :: ifile
+    integer :: ts_unit = 1234
+
+    call ts_assert_init(ts)
+    call ts_assert_writemode(ts)
+
+    open (ts_unit, file='ts.'//io_adjustl(ifile), form='unformatted', position='append')
+    write(ts_unit) itype
+    write(ts_unit) cooCart(1:3)
+    write(ts_unit) forCart(1:3)
+    close(ts_unit)
+
+  end subroutine ts_write_atom_info_MPI
+
+  !--------------------------------------------------------------------!
+
+  subroutine ts_write_sf_info_MPI(ts, nsf, sfval, ifile)
+
+    implicit none
+
+    type(TrnSet),                       intent(inout) :: ts
+    integer,                            intent(in)    :: nsf
+    double precision, dimension(nsf),   intent(in)    :: sfval
+    integer,          intent(in)    :: ifile
+    integer :: ts_unit = 1234
+
+    call ts_assert_init(ts)
+    call ts_assert_writemode(ts)
+
+    open (ts_unit, file='ts.'//io_adjustl(ifile), form='unformatted', position='append')
+    write(ts_unit) nsf
+    write(ts_unit) sfval(1:nsf)
+    close(ts_unit)
+
+  end subroutine ts_write_sf_info_MPI
+
+  !--------------------------------------------------------------------!
+  !                            state checks                            !
+  !--------------------------------------------------------------------!
+
+  subroutine ts_assert_init(ts)
+    implicit none
+    type(TrnSet), intent(in) :: ts
+    if (.not. ts%init) then
+       write(0,*) "Error: training set not initialized."
+       stop
+    end if
+  end subroutine ts_assert_init
+
+  subroutine ts_assert_writemode(ts)
+    implicit none
+    type(TrnSet), intent(in) :: ts
+    if (trim(ts%mode) /= 'write') then
+       write(0,*) "Error: training set not in 'write' mode."
+       stop
+    end if
+  end subroutine ts_assert_writemode
+
+  subroutine ts_assert_readmode(ts)
+    implicit none
+    type(TrnSet), intent(in) :: ts
+    if (trim(ts%mode) /= 'read') then
+       write(0,*) "Error: training set not in 'read' mode."
+       stop
+    end if
+  end subroutine ts_assert_readmode
+
+end module trainset_MPI
